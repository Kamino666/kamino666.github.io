<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux配置Clash</title>
    <link href="/2021/09/30/Linux%E9%85%8D%E7%BD%AEClash/"/>
    <url>/2021/09/30/Linux%E9%85%8D%E7%BD%AEClash/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux配置Clash"><a href="#Linux配置Clash" class="headerlink" title="Linux配置Clash"></a>Linux配置Clash</h1><p><strong>本文参考：</strong></p><p><a href="https://zhuanlan.zhihu.com/p/369344633">Linux下安装&amp;配置Clash以实现代理上网 - 知乎 (zhihu.com)</a></p><p><a href="https://lancellc.gitbook.io/clash/">Introduce - Clash (gitbook.io)</a></p><p>这篇文章用来防止忘记怎么配Clash，干货笔记。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><strong>Github Release：</strong><a href="https://github.com/Dreamacro/clash/releases">Releases · Dreamacro/clash (github.com)</a></p><p>从Assets中找到Linux amd64的gz文件，下载下来</p><p>网盘备份：<a href="https://drive.google.com/file/d/1-F9O79RvVYu9iIdciZXAesxunKWoIVGa/view?usp=sharing">Google Drive</a> <a href="https://pan.baidu.com/s/1-GwOpETvLqGSQwg5IRs6xQ">百度网盘:ucjy</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>不要直接复制。Clash基本就靠config.yaml运行，不用输入什么参数。</p><p>切换模式、切换节点都在config.yaml里弄。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">su  <span class="hljs-comment"># 用管理员账号</span><br>gunzip xxx.gz  <span class="hljs-comment"># gunzip解压gz文件</span><br><span class="hljs-built_in">cd</span> &lt;folder&gt;  <span class="hljs-comment"># 进入有那个可执行文件的文件夹</span><br>wget -O config.yaml [订阅链接]  <span class="hljs-comment"># 下载订阅链接，或者直接把文件重命名为config.yaml</span><br>chmod +x clash  <span class="hljs-comment"># 该权限让其可执行</span><br>./clash <span class="hljs-comment"># 运行梯子</span><br>./clash -d /etc/clash   <span class="hljs-comment"># 指定config目录</span><br>./clash -f /etc/clash/config.yaml  <span class="hljs-comment"># 指定config文件</span><br></code></pre></td></tr></table></figure><p>安装好了只是占了端口，搭好梯子，还需要配置系统把数据通过那个端口送出去。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">settings <span class="hljs-built_in">set</span> org.gnome.system.proxy mode <span class="hljs-string">&#x27;manual&#x27;</span><br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.http port 7890<br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.http host <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.https port 7890<br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.https host <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.socks port 7891<br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy.socks host <span class="hljs-string">&#x27;127.0.0.1&#x27;</span><br>gsettings <span class="hljs-built_in">set</span> org.gnome.system.proxy ignore-hosts <span class="hljs-string">&quot;[&#x27;localhost&#x27;, &#x27;127.0.0.0/8&#x27;, &#x27;::1&#x27;]&quot;</span><br></code></pre></td></tr></table></figure><p>这里面第一行是开启的命令，剩下是配置的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">settings <span class="hljs-built_in">set</span> org.gnome.system.proxy mode <span class="hljs-string">&#x27;manual&#x27;</span>  <span class="hljs-comment"># 开启</span><br>settings <span class="hljs-built_in">set</span> org.gnome.system.proxy mode <span class="hljs-string">&#x27;none&#x27;</span>    <span class="hljs-comment"># 关闭</span><br></code></pre></td></tr></table></figure><p>接下来就可以使用了</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>用curl命令测试网站：<code>curl www.youtube.com</code></p><p>别用ping，ping不通的，ping用ICMP协议在计算机网络的网络层，socks代理在运输层。</p>]]></content>
    
    
    <categories>
      
      <category>梯子</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git原理</title>
    <link href="/2021/09/22/Git%E5%8E%9F%E7%90%86/"/>
    <url>/2021/09/22/Git%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Git原理"><a href="#Git原理" class="headerlink" title="Git原理"></a>Git原理</h1><p>[TOC]</p><h2 id="仓库-repository"><a href="#仓库-repository" class="headerlink" title="仓库 (repository)"></a>仓库 (repository)</h2><p>仓库是git中最大的单位，就是一份代码/项目所在的地方，在实际中，就是一个目录(category)。</p><p>仓库可以通过<code>git init</code>命令来创建，创建之后，会出现一个<code>.git</code>的隐藏目录，里面保存着Git所需要的文件。</p><p>仓库里的文件一开始是空的，即使实际中的目录有文件，我们需要手动将文件添加进仓库（的暂存区），使用<code>git add &lt;file&gt;</code>，可以一次添加多个文件，也可以使用通配符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add 1.txt<br>git add 1.txt 2.txt<br>git add *.txt<br>git add ./data/*<br></code></pre></td></tr></table></figure><p>添加文件之后，就可以使用<code>git commit</code>命令进行提交，commit就是把暂存区(Stage)的改动一次性提交给仓库(实际上是分支branch)，在提交的时候，可以附带一些信息（这点是强烈推荐）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;message&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>commit的消息也可以选择性地遵守一定的规则</p><p>feat: 新功能<br>change：需求变更<br>fix：缺陷修复<br>test：修改测试代码<br>docs：文档变更<br>style：代码格式调整<br>refactor：代码重构</p></blockquote><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>Git最重要的特点就是能够版本回退，回退的单位是commit。要回退到某个commit，需要先知道对应的<code>commit id</code>，这个id是用SHA1算出来的随机字符串。</p><p>回退的时候使用的是<code>git reset</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset --hard HEAD^  <span class="hljs-comment"># 回退到上一个版本，使用hard模式 HEAD表示当前 HEAD^表示上一个</span><br>git reset --hard 3s56fv  <span class="hljs-comment"># 跳转到某个commit id，id可以不用打全</span><br></code></pre></td></tr></table></figure><p>要找到想要的commit id，可以用<code>git log</code>来看过去，假如已经在“过去”，可以用<code>git reflog</code>来看未来。要从乱七八糟的log中找到你要的commit，那就得看你的commit message有没有好好写了。</p><h2 id="文件撤销修改-discard-changes-rollback"><a href="#文件撤销修改-discard-changes-rollback" class="headerlink" title="文件撤销修改(discard changes/rollback)"></a>文件撤销修改(discard changes/rollback)</h2><p>假如你不是想回退整个版本，而是改动一个文件后不想要改动了，那就可以使用<code>git checkout</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -- &lt;file&gt;<br><span class="hljs-comment"># 1. 假如file还没有放进暂存区，即没git add，那么会撤销到和仓库里一样的状态</span><br><span class="hljs-comment"># 2. 假如file已经git add了，那么会撤销到add时的状态</span><br></code></pre></td></tr></table></figure><p>假如想把一个已经放进暂存区的文件撤回到和仓库一样的状态，可以使用之前提到的<code>git reset</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git reset HEAD &lt;file&gt;  <span class="hljs-comment"># 把文件的暂存区修改回退到工作区</span><br></code></pre></td></tr></table></figure><p>假如要从仓库中删除一个文件，那么应该使用<code>git rm</code>命令，假如是误删除了一个文件，也可以使用和上面一样的<code>git checkout</code>命令来恢复。</p><h2 id="添加远程库、推送"><a href="#添加远程库、推送" class="headerlink" title="添加远程库、推送"></a>添加远程库、推送</h2><p>假如想要将仓库共享出去，那么可以使用<code>git remote add</code>命令添加远程库，远程库的名字一般都默认为origin</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:用户名/库名.git  <span class="hljs-comment"># 添加一个叫做origin的远程库</span><br></code></pre></td></tr></table></figure><p>之后把本地库内容推送到远程库上可以使用<code>git push</code>命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master  <span class="hljs-comment"># origin是远程库名 master是分支名</span><br></code></pre></td></tr></table></figure><p>假如是想从远程库中下载一份到本地，使用<code>git clone</code>命令，链接在Github的repo主页都会写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> &lt;链接&gt;<br></code></pre></td></tr></table></figure><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>每次commit，都会有一条时间线，这个时间线就是分支(branch)。默认的分支叫做master或者main，<code>HEAD</code>指向当前分支，下面是分支创建切换的基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git checkout -b newbranch  <span class="hljs-comment"># 创建并让HEAD指向这个新分支</span><br>git branch newbranch  <span class="hljs-comment"># 创建新分支</span><br>git checkout newbranch  <span class="hljs-comment"># HEAD指向某个分支</span><br>git branch  <span class="hljs-comment"># 查看分支</span><br>git branch -d newbranch  <span class="hljs-comment"># 删除分支</span><br><span class="hljs-comment"># git还提供了新的切换分支命令 git switch</span><br></code></pre></td></tr></table></figure><p>有多个分支时，可以合并分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git merge 分支名  <span class="hljs-comment"># 将某个分支合并到当前HEAD指向的那个分支</span><br></code></pre></td></tr></table></figure><p>对于分支管理，建议master分支用来发布版本，然后新建一个dev分支，所有人的改动都在dev分支上进行，有大版本更新时再合并到master。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210922131104.png" alt="来源：廖雪峰"></p><h2 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h2><p>git的拉取可以分为<code>fetch</code>、<code>pull</code>两种，<code>fetch</code>将远程主机的最新内容拉取到本地，需要检查再判断是否合并到本机，而<code>pull</code>则是拉取下来直接合并，但是可能产生冲突。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git fetch origin &lt;branch&gt;  <span class="hljs-comment"># </span><br>git merge FETCH_HEAD  <span class="hljs-comment"># 把刚才fetch的合并</span><br>git pull origin &lt;remote_branch&gt;:&lt;local_branch&gt;  <span class="hljs-comment"># 直接pull</span><br></code></pre></td></tr></table></figure><p>如图经常有这种冲突的情况，本地dev分支进行了改动，远程master分支也进行了改动。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210922142749.png" alt="git.drawio"></p><p>此时可以采取解决方案1：<strong>把merge到master分支</strong></p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210922143448.png" alt="git-Page-2.drawio"></p><p>但是这样不太好看，于是可以采取解决方法2：<strong>rebase再push</strong></p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210922144606.png" alt="git-Page-2.drawio (1)"></p><p>假如有冲突的话，可以在pycharm里面的Update Project打开代码解决冲突的三视窗口，在这里可解决代码冲突。这个不是git的命令，是pycharm的。</p><h2 id="藏匿stash"><a href="#藏匿stash" class="headerlink" title="藏匿stash"></a>藏匿stash</h2><p>假如你在某个分支上工作到一半时，想切换到master分支去临时修复一个bug，可以通过<code>git stash</code>命令保存当前尚未commit的任务。</p><blockquote><p>假如你没有stash就切换分支，会发现当前状态还是在dev改动后的状态</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git stash  <span class="hljs-comment"># 暂时藏匿工作</span><br>git stash list  <span class="hljs-comment"># 查看stash</span><br>git stash apply  <span class="hljs-comment"># 恢复stash</span><br>git stash drop  <span class="hljs-comment"># 删除stash</span><br>git stash pop  <span class="hljs-comment"># 恢复stash并删除</span><br>git stash apply stash@&#123;0&#125;  <span class="hljs-comment"># 恢复某个stash</span><br></code></pre></td></tr></table></figure><h2 id="pick一个commit"><a href="#pick一个commit" class="headerlink" title="pick一个commit"></a>pick一个commit</h2><p>假如想复制别的分支的某个commit到当前分支，可以使用<code>git cherry-pick</code>命令，相当于在这个分支做了一次commit。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git cherry-pick &lt;commit id&gt;  <span class="hljs-comment"># 将某个commit复制到当前分支</span><br></code></pre></td></tr></table></figure><h2 id="标签-Tag"><a href="#标签-Tag" class="headerlink" title="标签 Tag"></a>标签 Tag</h2><p>使用<code>git tag</code>命令可以为当前commit打上一个标签，差不多就是给commit起个别名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git tag &lt;info&gt;  <span class="hljs-comment"># 给当前commit打标签</span><br>git tag &lt;info&gt; &lt;commit id&gt;  <span class="hljs-comment"># 给指定commit打标签</span><br>git tag -a &lt;tagname&gt; -m <span class="hljs-string">&quot;message&quot;</span>  <span class="hljs-comment"># 给标签分成名字和内容</span><br>git tag  <span class="hljs-comment"># 查看标签</span><br></code></pre></td></tr></table></figure><p>但是push的时候假如要加标签，需要一个额外的参数<code>--tags</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push origin master --tags<br>git push origin &lt;tagname&gt;  <span class="hljs-comment"># 或者push特定的tag名</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过transformer实现的细粒度分类模型——TransFG</title>
    <link href="/2021/04/30/TransFG-Fine-Grained/"/>
    <url>/2021/04/30/TransFG-Fine-Grained/</url>
    
    <content type="html"><![CDATA[<h1 id="TransFG"><a href="#TransFG" class="headerlink" title="TransFG"></a>TransFG</h1><p><code>TransFG: A Transformer Architecture for Fine-grained Recognition</code></p><p>关键词：计算机视觉、Transformer、细粒度分类、ViT</p><h2 id="（前置）ViT：Vision-Transformer"><a href="#（前置）ViT：Vision-Transformer" class="headerlink" title="（前置）ViT：Vision Transformer"></a>（前置）ViT：Vision Transformer</h2><p>用来取代CNN，优点是节约计算资源。其适合在超大规模数据集（14M~300M）上训练。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210426224957.png" alt="img"></p><p>输入由于要是序列，就将图像切分成一系列patch。</p><blockquote><p>pretrained model命名：</p><p>B：base 参数最少    L：Large 参数多    H：Huge 参数最多</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210426231155.png" alt="image-20210426231155245"></p><p>一些可能用到的术语：</p><ul><li>R50+：结合Resnet50，将Resnet50的特征map输入</li><li>ViT-L/16：这里的16指的是patch的大小是16</li><li>BiT：改动的ResNet，用来做对比的</li></ul></blockquote><h2 id="论文要解决的问题"><a href="#论文要解决的问题" class="headerlink" title="论文要解决的问题"></a>论文要解决的问题</h2><p>传统的计算Fine-grained的方法是将图像的特定区域过CNN后区分，并且可能需要额外标注。</p><p>TransFG可以减少复杂度，提高性能。（减少复杂度……然鹅这模型还是很大）</p><p>率先尝试使用Vision Transformer来解决细粒度分类问题。</p><h2 id="模型主体架构"><a href="#模型主体架构" class="headerlink" title="模型主体架构"></a>模型主体架构</h2><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429133624.png" alt="image-20210429133616028"></p><p>这里面每一个Transformer Layer都是下面这种多头self-attention，作者通过加载ViT的权重使用预训练模型，不冻结权重。（论文图是12 Layer）</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429133906.png" alt="image-20210429133906473" style="zoom: 50%;" /><h2 id="作者针对Fine-Grained做出的优化"><a href="#作者针对Fine-Grained做出的优化" class="headerlink" title="作者针对Fine-Grained做出的优化"></a>作者针对Fine-Grained做出的优化</h2><ol><li><p>原ViT是粗暴的切分原图像成16patch，作者增加了重叠部分<strong>overlap</strong>，设置超参数S来控制重叠的多少。S越小效果越好但耗算力越多。</p></li><li><p><strong>PSM(Part Selection Module)</strong> 选择模块。作者在前11层提取每一层输出的<code>α</code>，然后在Layer的维度相乘</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429143058.png" alt="image-20210429143058723"></p><p>得到了Seq个$\alpha_{final}$，$\alpha_{final}$获取了所有层对信息的注意力。</p><p>然后选择$\alpha_{final}$最大的K个（Multi-head的个数）信息$A_k$作为下一层的输入。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429144508.png" alt="image-20210429144430161"></p><p>原本ViT会在0位置新加一个额外的Token，叫做classification token，用来保存总信息。</p><p>所以用PSM之后，最后一层attention变得hard了起来，之前层的总体信息保存在0号token中，而每一个patch对应的特征则经过选择之后再送入最后一层。</p></li><li><p>Contrastive feature learning 对比特征学习</p><p>作者认为交叉熵不够，还加入了<code>Contrastive Loss</code>。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429174308.png" alt="image-20210429174303822"></p><p>详见笔记Contrastive Loss与Triplet Loss</p><blockquote><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429195820.png" alt="img"></p><p>假如要改进，也许可以改成<code>Triplet Loss</code></p></blockquote></li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429195454.png" alt="image-20210429195416444"></p><p>除此以外还有iNat2017、Dogs、NABirds等数据集，都是state of art。</p><ul><li><p>重叠patch的提升</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429195559.png" alt="image-20210429195556264"></p></li><li><p>PSM的提升</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429195614.png" alt="image-20210429195610172"></p></li><li><p>Contrastive的提升</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210429195648.png" alt="image-20210429195648035"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>机器学习</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python下使用MySQL（包括MySQL教程）</title>
    <link href="/2021/04/05/Python-MySQL/"/>
    <url>/2021/04/05/Python-MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="Python下使用MySQL（包括MySQL教程）"><a href="#Python下使用MySQL（包括MySQL教程）" class="headerlink" title="Python下使用MySQL（包括MySQL教程）"></a>Python下使用MySQL（包括MySQL教程）</h1><h2 id="MySQL基本使用"><a href="#MySQL基本使用" class="headerlink" title="MySQL基本使用"></a>MySQL基本使用</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>MySQL是一个<strong>开源</strong>的<strong>关系型数据库管理系统</strong>，即<strong>RDBMS</strong>(Relational Database Management System)。使用SQL语言访问数据库。</p><p><strong>关系型数据库</strong>是<strong>依据关系模型</strong>来创建的数据库，关系模型包含“一对一、一对多、多对多”等，分别对应一本书的ISBN、一本书的作者、一个班的老师和学生。<strong>一个关系型数据库就是由二维表及其之间的练习组成的一个数据组织。</strong></p><table><thead><tr><th>关系</th><th>一张二维表，每个关系都有个名字，即表名</th></tr></thead><tbody><tr><td>元组</td><td>行，在数据库中叫做<strong>记录</strong></td></tr><tr><td>属性</td><td>列，在数据库中交做<strong>字段</strong></td></tr><tr><td>域</td><td>属性的取值范围，就是一列的取值限制（数字/字符串）</td></tr><tr><td>关键字</td><td>唯一标识元组的属性，在数据库中叫<strong>主键</strong>，由一个或多个列组成</td></tr><tr><td>关系模式</td><td>对关系的描述。关系名（属性1，属性2…）在数据库中叫<strong>表结构</strong></td></tr></tbody></table><p><strong>非关系型数据库</strong>类似一个巨大的map数据结构或者键值对数据结构。结构不固定，每一个元组可以有不一样的字段。</p><blockquote><p>MySQL由瑞典MySQL AB公司开发，这时候Oracle和MySQL是对头，后来被Sun公司收购，Sun后来又被Oracle公司收购。</p></blockquote><h3 id="MySQL的服务结构"><a href="#MySQL的服务结构" class="headerlink" title="MySQL的服务结构"></a>MySQL的服务结构</h3><pre><code class=" mermaid">graph LRA(MySQL-client) --&gt;|SQL|B[MySQL-server]B --&gt; AB --&gt; C[数据库1]C --&gt; C1[数据表1]C --&gt; C2[数据表2]C --&gt; C3[数据表3]B --&gt; D[数据库2]B --&gt; E[数据库3]</code></pre><p>MySQL通过SQL语言来与服务器沟通，一个数据库服务器可以有多个数据库，每个数据库可以有多个数据表。</p><h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>包括<strong>数据类型</strong>和<strong>约束</strong>。</p><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">范围（signed）</th><th align="left">范围（unsigned）</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">TINYINT</td><td align="left">1 字节</td><td align="left">(-128，127)</td><td align="left">(0，255)</td><td align="left">小整数值</td></tr><tr><td align="left">SMALLINT</td><td align="left">2 字节</td><td align="left">(-32 768，32 767)</td><td align="left">(0，65 535)</td><td align="left">大整数值</td></tr><tr><td align="left">MEDIUMINT</td><td align="left">3 字节</td><td align="left">(-8 388 608，8 388 607)</td><td align="left">(0，16 777 215)</td><td align="left">大整数值</td></tr><tr><td align="left">INT或INTEGER</td><td align="left">4 字节</td><td align="left">(-2 147 483 648，2 147 483 647)</td><td align="left">(0，4 294 967 295)</td><td align="left">大整数值</td></tr><tr><td align="left">BIGINT</td><td align="left">8 字节</td><td align="left">(-9,223,372,036,854,775,808，9 223 372 036 854 775 807)</td><td align="left">(0，18 446 744 073 709 551 615)</td><td align="left">极大整数值</td></tr><tr><td align="left">FLOAT</td><td align="left">4 字节</td><td align="left">(-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38)</td><td align="left">0，(1.175 494 351 E-38，3.402 823 466 E+38)</td><td align="left">单精度 浮点数值</td></tr><tr><td align="left">DOUBLE</td><td align="left">8 字节</td><td align="left">(-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308)</td><td align="left">双精度 浮点数值</td></tr><tr><td align="left">DECIMAL</td><td align="left">DECIMAL(M,D) ，如果M&gt;D，为M+2否则为D+2</td><td align="left">依赖于M和D的值</td><td align="left">依赖于M和D的值</td><td align="left">小数值</td></tr></tbody></table><table><thead><tr><th align="left">类型</th><th align="left">大小 (字节)</th><th align="left">范围</th><th align="left">格式</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">DATE</td><td align="left">3</td><td align="left">1000-01-01/9999-12-31</td><td align="left">YYYY-MM-DD</td><td align="left">日期值</td></tr><tr><td align="left">TIME</td><td align="left">3</td><td align="left">‘-838:59:59’/‘838:59:59’</td><td align="left">HH:MM:SS</td><td align="left">时间值或持续时间</td></tr><tr><td align="left">YEAR</td><td align="left">1</td><td align="left">1901/2155</td><td align="left">YYYY</td><td align="left">年份值</td></tr><tr><td align="left">DATETIME</td><td align="left">8</td><td align="left">1000-01-01 00:00:00/9999-12-31 23:59:59</td><td align="left">YYYY-MM-DD HH:MM:SS</td><td align="left">混合日期和时间值</td></tr><tr><td align="left">TIMESTAMP</td><td align="left">4</td><td align="left">1970-01-01 00:00:00/2038结束时间是第 <strong>2147483647</strong> 秒，北京时间 <strong>2038-1-19 11:14:07</strong>，格林尼治时间 2038年1月19日 凌晨 03:14:07</td><td align="left">YYYYMMDD HHMMSS</td><td align="left">混合日期和时间值，时间戳</td></tr></tbody></table><table><thead><tr><th align="left">类型</th><th align="left">大小</th><th align="left">用途</th></tr></thead><tbody><tr><td align="left">CHAR</td><td align="left">0-255字节</td><td align="left">定长字符串</td></tr><tr><td align="left">VARCHAR</td><td align="left">0-65535 字节</td><td align="left">变长字符串</td></tr><tr><td align="left">TINYBLOB</td><td align="left">0-255字节</td><td align="left">不超过 255 个字符的二进制字符串</td></tr><tr><td align="left">TINYTEXT</td><td align="left">0-255字节</td><td align="left">短文本字符串</td></tr><tr><td align="left">BLOB</td><td align="left">0-65 535字节</td><td align="left">二进制形式的长文本数据</td></tr><tr><td align="left">TEXT</td><td align="left">0-65 535字节</td><td align="left">长文本数据</td></tr><tr><td align="left">MEDIUMBLOB</td><td align="left">0-16 777 215字节</td><td align="left">二进制形式的中等长度文本数据</td></tr><tr><td align="left">MEDIUMTEXT</td><td align="left">0-16 777 215字节</td><td align="left">中等长度文本数据</td></tr><tr><td align="left">LONGBLOB</td><td align="left">0-4 294 967 295字节</td><td align="left">二进制形式的极大文本数据</td></tr><tr><td align="left">LONGTEXT</td><td align="left">0-4 294 967 295字节</td><td align="left">极大文本数据</td></tr></tbody></table><table><thead><tr><th>约束</th><th>解释</th></tr></thead><tbody><tr><td>主键(Primary key)</td><td>物理上存储的顺序</td></tr><tr><td>非空(not NULL)</td><td>不允许填空值</td></tr><tr><td>唯一(unique)</td><td>不允许重复</td></tr><tr><td>默认(default)</td><td>不填写时用默认值</td></tr><tr><td><em>外键(foreign key)</em></td><td><em>只能填写另一处字段的值</em></td></tr></tbody></table><h3 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>SQL(Structured Query Language)，指结构化查询语言。<strong>SQL语言不区分大小写。</strong></p><p>SQL语句的分号不是必须的，使用分号可以分隔多条SQL语句，可以在对服务器相同请求中执行一条以上的SQL语句。</p><h4 id="数据库操作-不常用"><a href="#数据库操作-不常用" class="headerlink" title="数据库操作(不常用)"></a>数据库操作(不常用)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看所有数据库<br>show databases;<br>-- 使用数据库<br>use 数据库名;<br>-- 查看当前数据库<br>select database();<br>-- 创建数据库<br>create database 数据库名 charset=utf8;<br>-- 删除数据库<br>drop database 数据库名<br></code></pre></td></tr></table></figure><h4 id="数据表操作"><a href="#数据表操作" class="headerlink" title="数据表操作"></a>数据表操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查看当前所有数据表<br>show tables;<br>-- 查看表结构<br>desc 名字<br>-- 删除表<br>drop table 名字<br>-- 查看表的创建语句<br>show create table 名字<br>-- 创建表<br>create table 表名(字段名字 数据结构 约束,字段名字 数据结构);<br>create table people(<br>    id int unsigned primary key not null auto_increment, <br>    age int unsigned,<br>    height decimal(5,2) default 1.70<br>    gender enum(&quot;男&quot;,&quot;女&quot;,&quot;保密&quot;) default &quot;保密&quot;<br>    name varchar(30)<br>);  <br>-- 这个表id是主键，且不能空，且自动增长；age是无符号类型；height是2位小数的5位（包括小数位）数；gender只能有三种值，默认为保密<br><br>-- 增删查改字段<br>alter table 名字 操作 字段名字 数据结构 约束<br>-- 添加<br>alter table people add birthday datetime<br>-- 修改-不重命名<br>alter table people modify birthday date<br>-- 修改-重命名<br>alter table people change birthday birth date<br>-- 删除<br>alter table people drop height<br></code></pre></td></tr></table></figure><h4 id="数据的增删改查（重重重点）-CURD-create-update-retrieve-delete"><a href="#数据的增删改查（重重重点）-CURD-create-update-retrieve-delete" class="headerlink" title="数据的增删改查（重重重点）(CURD-create update retrieve delete)"></a>数据的增删改查（重重重点）(CURD-create update retrieve delete)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 增加<br>-- 完全插入：参数必须对应字段<br>insert into 表名字 values(字段参数)<br>-- 若有些字段不想写,且可以不用写，可用null或者default占位<br>insert into people(default,13,1.80,&quot;男&quot;,&quot;Tom&quot;)<br>-- 部分插入 <br>insert into 表名字 (字段名) values (加入的数据)<br>insert into people (age, name) values (13,&quot;Jack&quot;)<br>-- 多行插入<br>insert into 表名字 values (字段参数1),(字段参数2)<br>insert into 表名字 (字段名) values (加入的数据1),(加入的数据2)<br><br>-- 修改<br>-- 修改所有记录该字段的值<br>update 表名字 set 字段1=新值1，字段2=新值2<br>-- 修改一定某个记录中字段的值 where <br>update 表名字 set 字段=新值 where 字段与值关系(可用大于小于号)<br>update people set age = 18 where id=1<br><br>-- 删除<br>-- 清空表！别用！<br>delete from 表名字<br>-- 删除某个记录<br>delete from 表名字 where<br>-- 逻辑删除，新增一个is_delete操作，标记这行可不可用<br>alter table 表名字 add is_delete bit default 0<br>update 表名字 set is_delete where ...<br><br>-- 查询（基本）<br>-- 查询表所有记录<br>select * from 表名字<br>-- 查询某个记录<br>select * from 表名字 where 字段与值关系<br>-- 查询某个字段<br>select 字段名字 from 表名字 <br>-- 指定别名，指定别名后不能用本名了<br>select 字段名字 as 别名 from 表名字 as 别名<br>select 表名.字段名 from 表名<br>-- 指定列的顺序<br>select 第一个字段,第二个字段 from 表名字<br>-- 去重<br>select distinct 字段 from 表名<br></code></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 条件查询<br>-- 使用where关键字<br>&gt; &lt; &gt;= &lt;= -- 和别的语言一样<br>= -- 单等于表示判断<br>&lt;&gt; !=  -- 不等于<br>and or not  -- 与或非，同Python<br>()  -- 括号，优先级很高<br><br>-- 模糊查询<br>-- 使用like关键字<br>-- % 替换0个或多个 | _ 替换一个 | [charlist] 字符列中任意单一字符 | []不在字符列中的任何单一字符<br>select name from people where name like &quot;T%&quot;  -- 名字以T开头<br>-- 使用rlike关键字<br>-- 正则表达式<br>select name from people where name rlike &quot;正则表达式&quot;<br><br>-- 范围查询<br>-- （非连续）使用in和not in关键字  <br>select name from people where age in (12,18,6)  -- &#123;12,18,6&#125;<br>-- （连续）使用between...and...关键字和not between...and...关键字 左闭右闭区间<br>select name from people where age between 6 and 18  -- [6,18]<br><br>-- 空判断<br>-- 使用is null关键字和is not null关键字<br>select name from people where age is null<br></code></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- order by 字段<br>-- asc 升序(从小到大)   desc 降序<br>select name from people order by age<br>select name from people order by age asc<br>-- order by 多个字段<br>-- 在第一个字段相同情况下，再按第二个字段排...<br>select name from people order by age asc, id desc<br></code></pre></td></tr></table></figure><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 聚合函数只能输出一个结果<br>-- count 总数<br>-- 就是计算输出的东西一共多少行，结果表头是count(*)，可用as<br>select count(*) from people<br>select count(*) as &quot;人数&quot; from people<br>-- max 最大值  min 最小值<br>select max(age) from people<br>select min(height) from people<br>-- sum 求和<br>select sum(age) from people<br>-- avg 平均<br>select avg(age) from people<br>select sum(age) / count(*) from people  -- select后可以用运算和多个函数<br>-- round(x,保留小数位数) 四舍五入<br>select rount(avg(age),1) from people  -- 保留平均数的一位小数<br></code></pre></td></tr></table></figure><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- group by<br>-- xxx是能唯一标记分组后各组之间不同的字段<br>-- xxx不能填*<br>select gender from people group by gender  -- 1*<br><br>-- 与聚合函数一起用，查找不同性别各自的人数<br>select gender,count(*) from people group by gender<br><br>-- group_concat(字段1,字段2) 写什么有什么，链接所有参数<br>-- 查询group中某字段的总和<br>select gender,group_concat(name) from people group by gender  -- 2*<br>select gender,group_concat(name,age) from people group by gender<br>select gender,group_concat(name,&quot;_&quot;，age) from people group by gender  -- 3* <br><br>-- 与where一起用，先判断，然后从中分组<br>select gender,group_concat(name) from people where age&lt;18 group by gender<br><br>-- having 显示符合条件的分组，与where不同的是写在group后面<br>-- 所以where是对表进行判断，having是对分组结果进行判断<br>select gender,group_concat(name) from people group by gender having min(age)&lt;5  -- 4*<br></code></pre></td></tr></table></figure><blockquote><p>1* 的结果</p><table><thead><tr><th>gender</th><th>count(*)</th></tr></thead><tbody><tr><td>男</td><td>5</td></tr><tr><td>女</td><td>3</td></tr></tbody></table><p>2* 的结果</p><table><thead><tr><th>gender</th><th>group_concat(name)</th></tr></thead><tbody><tr><td>男</td><td>Mike, Leo, Tom</td></tr><tr><td>女</td><td>Lucy, Mary</td></tr></tbody></table><p>3* 的结果</p><table><thead><tr><th>gender</th><th>group_concat(name,”_”，age)</th></tr></thead><tbody><tr><td>男</td><td>Mike_12, Leo_18, Tom_6</td></tr><tr><td>女</td><td>Lucy_12, Mary_3</td></tr></tbody></table><p>4* 的结果</p><table><thead><tr><th>gender</th><th>group_concat(name)</th></tr></thead><tbody><tr><td>女</td><td>Lucy, Mary</td></tr></tbody></table></blockquote><h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 使用limit限制<br>-- limit 数字m  查询前m个<br>select * from people limit 5<br>-- limit 数字n,数字m  查询从n开始，查询共m个<br>-- n从0开始<br>select * from peolpe limit 2,6  -- [3,9]<br>select * from peolpe limit 0,5  -- [1,5]<br>select * from peolpe limit 5,5  -- [6,10]<br>select * from peolpe limit 10,5  -- [11,15]<br>-- limit放最后<br>select * from peolpe order by age limit 0,5  -- 按age排序的[1,5]<br></code></pre></td></tr></table></figure><h4 id="链接查询"><a href="#链接查询" class="headerlink" title="链接查询"></a>链接查询</h4><p>结合多个表的查询，比如一张表存放班级信息，另一张表存放同学信息，要显示同学信息的同时再显示该同学的班级信息，就用链接查询。</p><p>略。</p><h4 id="自关联"><a href="#自关联" class="headerlink" title="自关联"></a>自关联</h4><p>一个表中某个字段用的是另一个字段的值</p><p>比如公司中上下属关系，A是B的属下，B是D的属下，C是D的属下，于是数据表中可以新建一个字段，表示每个员工的老板是谁，同时这个老板也在同一个表中，并且也有他的老板。</p><p>略。</p><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>select中嵌入另一个select语句</p><p>比如查找人群中最高的人的信息，需要select最高的人，然后select *</p><p>略。</p><h2 id="Python-与-MySQL-交互"><a href="#Python-与-MySQL-交互" class="headerlink" title="Python 与 MySQL 交互"></a>Python 与 MySQL 交互</h2><pre><code class=" mermaid">graph LRA(开始) --&gt; B[创建connection]B --&gt; C[获取cursor]C --&gt; D[操作]D --&gt; E[关闭cursor]E --&gt; F[关闭connection]F --&gt; G(结束)</code></pre><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pymysql <span class="hljs-keyword">import</span> *<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建connection</span><br>    conn = connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        port=<span class="hljs-number">3306</span>,<br>        user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>        password=<span class="hljs-string">&#x27;root&#x27;</span>,<br>        database=<span class="hljs-string">&#x27;study&#x27;</span>,<br>        charset=<span class="hljs-string">&#x27;utf8&#x27;</span><br>    )<br>    <span class="hljs-comment"># 获取cursor</span><br>    cursor = conn.sursor()<br>    <br>    <span class="hljs-comment"># 执行sql语句获取数据 select返回获取的行数</span><br>    cursor.execute(<span class="hljs-string">&quot;&quot;&quot;select * from people;&quot;&quot;&quot;</span>)<br>    <span class="hljs-comment"># 从游标中获取数据(fetch) </span><br>    <span class="hljs-comment"># fetchone()得到一个元组,然后游标向下走一行</span><br>    oneline = cursor.fetchone()<br>    <span class="hljs-comment"># fetchmany(int)元组里面套元组，然后游标向下走那么多行</span><br>    manylines = cursor.fetchmany(<span class="hljs-number">3</span>)<br>    <span class="hljs-comment"># fetchall() 元组里面套元组，获取游标下所有</span><br>    alllines = cursor.fetchall()<br>    <br>    <span class="hljs-comment"># 关闭游标</span><br>    cursor.close()<br>    <span class="hljs-comment"># 关闭连接</span><br>    conn.close()<br></code></pre></td></tr></table></figure><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><p>增删改操作需要增加一个提交connection.commit()操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pymysql <span class="hljs-keyword">import</span> *<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建connection</span><br>    conn = connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        port=<span class="hljs-number">3306</span>,<br>        user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>        password=<span class="hljs-string">&#x27;root&#x27;</span>,<br>        database=<span class="hljs-string">&#x27;study&#x27;</span>,<br>        charset=<span class="hljs-string">&#x27;utf8&#x27;</span><br>    )<br>    <span class="hljs-comment"># 获取cursor</span><br>    cursor = conn.sursor()<br>    <br>    <span class="hljs-comment"># 执行sql语句 返回生效行数</span><br>    cursor.execute(<span class="hljs-string">&quot;&quot;&quot;insert into people(name, age) values(&quot;Ash&quot;, 31);&quot;&quot;&quot;</span>)  <span class="hljs-comment"># 增</span><br>    cursor.execute(<span class="hljs-string">&quot;&quot;&quot;delete from people where id=6 ;&quot;&quot;&quot;</span>)  <span class="hljs-comment"># 删</span><br>    cursor.execute(<span class="hljs-string">&quot;&quot;&quot;update people set age=18 where name=&quot;Tom&quot;;&quot;&quot;&quot;</span>)  <span class="hljs-comment"># 改</span><br>    <br>    <span class="hljs-comment"># 取消所有请求 但是自动增长（例如id）会持续生效</span><br>    <span class="hljs-comment"># conn.rollback()</span><br>    <span class="hljs-comment"># 提交请求</span><br>    conn.commit()<br>    <span class="hljs-comment"># 关闭游标</span><br>    cursor.close()<br>    <span class="hljs-comment"># 关闭连接</span><br>    conn.close()<br></code></pre></td></tr></table></figure><h3 id="防止SQL注入"><a href="#防止SQL注入" class="headerlink" title="防止SQL注入"></a>防止SQL注入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 前略</span><br><br>name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要查询的人的名字：&quot;</span>)<br>cursor.execute(<span class="hljs-string">&quot;&quot;&quot;select * from people where name = &quot;&#123;&#125;&quot; &quot;&quot;&quot;</span>.<span class="hljs-built_in">format</span>(name))<br><span class="hljs-comment"># 输入 Tom</span><br><span class="hljs-comment"># 结果 (1,18,1.80,&quot;男&quot;,&quot;Tom&quot;)</span><br><span class="hljs-comment"># 输入 &quot;or 1=1 or &quot;1</span><br><span class="hljs-comment"># execute内容： select * from people where name = &quot;&quot;or 1=1 or &quot;1&quot;</span><br><span class="hljs-comment"># 结果输出所有人的名字</span><br><span class="hljs-comment"># SQL注入！！！！！</span><br><br><span class="hljs-comment"># 防止方法</span><br><span class="hljs-comment"># 构建参数列表</span><br>params = [name]<br>sql = <span class="hljs-string">&quot;select * from people where name=%s, id=%d, age=%d &quot;</span><br>cursor.execute(sql,params)  <span class="hljs-comment"># 自动填充</span><br><br><span class="hljs-comment">## 后略</span><br></code></pre></td></tr></table></figure><div class="note note-info">            <p>参考文献：</p><ol><li><a href="https://www.jianshu.com/p/fd7b422d5f93">https://www.jianshu.com/p/fd7b422d5f93</a></li><li><a href="https://www.runoob.com/sql/sql-intro.html">https://www.runoob.com/sql/sql-intro.html</a></li><li><a href="https://www.bilibili.com/video/av37278656">https://www.bilibili.com/video/av37278656</a></li></ol>          </div>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络爬虫进化史，原来你是这样的爬虫：第3期</title>
    <link href="/2021/04/05/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%9A%E7%AC%AC3%E6%9C%9F/"/>
    <url>/2021/04/05/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%9A%E7%AC%AC3%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫进化史，原来你是这样的爬虫：第3期"><a href="#网络爬虫进化史，原来你是这样的爬虫：第3期" class="headerlink" title="网络爬虫进化史，原来你是这样的爬虫：第3期"></a>网络爬虫进化史，原来你是这样的爬虫：第3期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一期，万维网经历了发展最迅速的时期，也经历了泡沫破裂的时期，而爬虫却在背地里偷偷壮大起来，仅仅1994这一年，爬虫的爬取能力就扩大了好几倍，而随着Google的天才工程师们的加入，爬虫也学会团结在一起集体行动。</p><p>不知道读者们还记不记得第一期的“常胜将军”</p><blockquote><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153701.png" alt="传统爬虫结构"></p><p>我们可以把爬虫想象为一位攻城掠地的常胜将军，他带着初始的补给去攻打一个个城池，每攻下一个城池就能获得新的补给，然后他就带着新的补给去攻打新的城池……直到他征服了全世界。</p></blockquote><p>在经过几年的磨砺之后，常胜将军手下的军队越来越强大，他的脑袋也越来越灵活，他已经能够率领军队同时进攻几个城池，在新的世纪到来之时，世界的变化越来越大，城池越来越坚固，将军是否还能经受住考验呢？</p><h2 id="Mercator"><a href="#Mercator" class="headerlink" title="Mercator"></a>Mercator</h2><p>Google爬虫是20世纪的王者，而它并不是完美的，假如说Google爬虫是为了Google搜索而生的专业搜索引擎爬虫，那么诞生于1999年的Mercator就是能为各类人员所用的万金油。</p><p>在上世纪90年代的程序设计界，Java和C++是最热门的两门计算机编程语言，而他们的共同特点就是OOP(Object Oriented Programming)，也就是面向对象，而面向对象又常伴随着模块化编程，模块化编程，是强调将计算机程序的功能分离成独立的、可相互改变的“模块”的软件设计技术，它使得每个模块都包含着执行预期功能的一个唯一方面所必需的所有东西。</p><p>我们要介绍的<strong>Mercator</strong>爬虫就是采用模块化设计思维，由Java语言实现的<strong>可拓展性</strong>爬虫。Mercator为爬虫领域带来了模块化设计，现在热门的Scrapy就是一个高度模块化的爬虫框架，当我们使用这种模块化设计的爬虫来进行某个爬取任务时，我们只要改动某一个模块的几十行代码就可以实现，并不需要动爬虫的核心(core)代码。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153706.png" alt="Mercator爬虫的各个模块"></p><p>Mercator爬虫的可拓展分为<strong>规模可拓展性</strong>(scalable)和<strong>功能可拓展性</strong>(extensible)两个方面，规模可拓展指的是无论你想用Mercator爬取一个小网站还是想爬取整个万维网，这个爬虫都会以正常的效率工作，而功能可拓展性指的是Mercator支持第三方来添加新模块来拓展功能，类似现在很多游戏都会加入的创意工坊(steam workshop)或者是Chrome浏览器的插件(Chrome plugins)。</p><p>除了上面提到的可拓展性以外，Mercator还有其他优点</p><ol><li>Mercator和Google一样可以在多台计算机上同时运行来提高效率，在四台Compaq DS20E 666 MHz Alpha服务器和160M的宽带下，Mercator每天就能够下载五千万个页面。</li><li>Mercator遵守爬虫礼仪，它的URL Frontier模块专门设计了前端(front-end)和后端(back-end)两个队列，前端队列负责给URL优先级排序，而后端队列负责保证爬虫礼仪。</li><li>Mercator具有可移植性，由于它是用Java实现的，所以它可以轻松地运行在任何装有Java虚拟机的系统上。</li></ol><p>这些优点让Mercator变得非常热门，再加上Mercator是当时公开信息和技术最多的爬虫，有非常多的人使用Mercator来进行研究，AltaVista搜索引擎就将它整合进去用来为美国和欧洲提供服务，还有人用它爬取了全网超过12TB的数据，甚至还有人用它来监控调查2000年美国总统选举时的与选举有关的网站。</p><h2 id="Polybot"><a href="#Polybot" class="headerlink" title="Polybot"></a>Polybot</h2><p>虽然Mercator靠着它的可拓展性红极一时，但是它有着一个很大的缺点——对硬件的需求高。Mercator虽然是个模块化的爬虫，但是要扩大规模就必须要多台相同的高性能机器一起运行多个Mercator程序，并且在Java尚未得到充足优化的时代，用Java写的程序普遍比C/C++更慢且占用内存更多，这使得使用Mercator的门槛很高。</p><p>2002年，另一个爬虫Polybot横空出世，它专门为低端机器进行了优化。</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153713.png" alt="image-20210121134837559" style="zoom:50%;" /><p>Polybot也是精心使用模块化设计的爬虫，比起Mercator，它的模块化程度显然更高，Mercator虽然能在多台机器上同时进行爬虫任务来提高效率，但是每台机器都运行的是同样复杂的任务，包括下载、提取、DNS解析等等，而Polybot则将它的每个模块完全分开，下载模块和DNS解析模块可以运行在不同的机器上，通过网络来交流和分配任务，这种方式让每台实体机器所负担的任务量大大减少，所以Polybot的使用者可以用更多台低成本机器来提升效率。</p><p>既然机器增多了，可能的故障也增多了，Polybot采用断点(checkpoint)技术来避免机器出问题导致爬取要从头开始。在开发者进行爬取试验的时候，由于各种因素程序崩溃了很多次，但是之后Polybot读取断点又继续进行任务了，实验结束后，Polybot总共在18天内爬取到了超过1.2亿个页面。</p><h2 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h2><p>在1999年5月的美国东北大学(NEU)，一个叫做Napster的软件免费软件在学生中流行起来，音乐爱好者们不用再担心没有钱去商店里买他们最喜欢的歌手的专辑了，Napster可以让他们互相分享MP3歌曲，在最火的时候，Napster拥有高达8000万的注册用户，无论是歌曲的数量还是下载速度，Napster都远远超过了他的竞争者们。</p><p>Napster的主要技术就是P2P(peer-to-peer)，也就是点对点网络或者对等网络。这种网络的特点就是没有中心服务器，仅依靠用户群来交换数据的互联网。这种网络的优点就是用户越多，效率越高，而且其中任何一个节点（用户）掉线了也不会影响整个网络。QQ、Skype（即时通话app）、SETI@home（利用全球各地计算机提供算力来寻找地外文明的项目）、BT下载（包括迅雷等）和比特币都使用了P2P技术。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153715.jpg" alt="Screengrab of the Napster program"></p><p>P2P的成功也引起了爬虫开发人员的注意，在2002年UbiCrawler爬虫率先使用了P2P网络来进行爬取任务。UbiCrawler和Mercator一样都是100%使用Java来实现的爬虫，然而UbiCrawler出色的设计让Java运行速度慢的劣势消失了，它在使用五台普通个人电脑的情况下，就实现了1000万每日的页面爬取量。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153717.png" alt="传统爬虫结构"></p><p>UbiCrawler使用到P2P技术的地方是URL-Seen模块，也就是爬虫从页面中提取到了超链接之后，需要判断这个链接是否已经被访问过，而随着不断爬取，已经访问过的链接数量可能是几百万几千万，高性能爬虫都会在这里遇到瓶颈。UbiCrawler通过一致性哈希算法(consistent hashing)，在爬虫的某个节点遇到一个URL之后，这个节点会将算出URL的hash值，然后判断这个URL应该由哪个节点负责处理，最后传递给那个节点，这样每个节点都只用处理总URL-Seen的一部分。</p><p>在之后有很多研究团队在UbiCrawler的基础上进行了改进，pSearch项目采用分布式哈希表(Distributed Hash Tables)来进一步提升P2P爬虫的性能，随着P2P的节点遍布全球，还有人通过考虑节点的地理位置来分配任务从而提升效率。</p><p>除了分布式爬虫，也有一些特立独行的爬虫只在一台机器上运行并发挥最大效率，比如2008年的IRLbot，在一台装有四核AMD皓龙处理器的服务器上，用41.27天爬取到了超过63亿个页面！</p><blockquote><h2 id="Wayback-Machine"><a href="#Wayback-Machine" class="headerlink" title="Wayback Machine"></a>Wayback Machine</h2><p>爬虫能做什么？从第一期到现在，开发爬虫的目的好像无非就是构建搜索引擎和对万维网进行规模研究，然而有一个组织使用爬虫制造了一个网站时光机，允许用户“回到过去”，这就是<a href="https://web.archive.org/">Wayback Machine</a>。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153719.png" alt="File:Wayback Machine logo 2010.svg"></p><p>这个时光机通过爬虫将从万维网上爬取到的页面存档下来，创始人Kahle和Gilliat希望以此能为整个互联网“普及所有知识”。时光机于1996年开始存档网页，在2001年正式公开时，它已经存档了超过100亿个页面，截止2018年9月，时光机已经存有了超过25PB的数据。</p><p>这是一个很有趣的网站，我们可以在上面找到很多网页之前的样子，比如B站在2011年的样子</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153724.png" alt="QQ图片20210122102337"></p><p>还有Youtube在2005年的样子</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153726.png" alt="image-20210122102625821"></p><p>还有2009年的steam</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153728.png" alt="image-20210122102958463"></p></blockquote><h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>这一期，我们的爬虫不仅开始成群结队了起来，而且他们的阵型变得更加灵活，我们的常胜将军带领的爬虫大军既能分散作战，用庞大的数量攻略城池，也能派出名将用高效的数据结构和算法来攻略城池，就算有几位将军倒下了，也会有其他将军顶替……纵使万维网的页面从最开始的一个页面发展到几百万几亿个页面，成千上万个站点，也避免不了爬虫爬取到每个角落。</p><p>然而，万维网并不是只在数字上有增长，当这些爬虫兴奋地在网上爬来爬去时，殊不知万维网已经成了一座冰山，掩盖在海底的不可见数据越来越多，这让传统的爬虫束手无策，他们需要进一步的升级才能看清水底的数据……</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210405153730.png" alt="What is Dark Web and Why You Should Access it Carefully! - GeeksforGeeks"></p><div class="note note-info">            <p>这篇文章也发布在下面这个公众号数媒极客，公众号里面有其他很有趣的文章，可以扫码看一看~</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/671DEC2D0C09137F94251F74940B395C.jpg" style="zoom:50%;" />          </div>]]></content>
    
    
    <categories>
      
      <category>爬虫历史系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用ngrok搭建属于自己的内网穿透教程（附错误处理）</title>
    <link href="/2021/03/04/ngrok-tutorial/"/>
    <url>/2021/03/04/ngrok-tutorial/</url>
    
    <content type="html"><![CDATA[<h1 id="用ngrok搭建属于自己的内网穿透教程（附错误处理）"><a href="#用ngrok搭建属于自己的内网穿透教程（附错误处理）" class="headerlink" title="用ngrok搭建属于自己的内网穿透教程（附错误处理）"></a>用ngrok搭建属于自己的内网穿透教程（附错误处理）</h1><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210304145345.png" alt="ngrok示意图"></p><p>ngrok是一个开源的反向代理，它可以创建一个隧道（tunnel），让互联网上的用户访问你的本地资源。</p><p>可以用来<strong>Minecraft等游戏的局域网联机</strong>、<strong>本地网站通过外网访问</strong>等。若用在另外一台服务器，还可以作为<strong>防火墙</strong>。（假如你要用来给游戏局域网联机，你可以把ngrok看作它打通了你和别人的局域网）</p><p>ngrok用go语言编写，需要<strong>go1.1+<strong>和</strong>Mercurial SCM</strong></p><p>ngrok分为两部分，<strong>ngrok</strong>和<strong>ngrokd</strong>，ngrokd是服务端，也就是代理服务器，用来接收外网的信息，然后通过隧道传到客户端的网络中；ngrok是客户端，哪台主机的局域网要暴露，就在哪台主机上运行。</p><p>GitHub：<a href="https://github.com/inconshreveable/ngrok">inconshreveable/ngrok: Introspected tunnels to localhost (github.com)</a></p><blockquote><p><strong>正向代理与反向代理的区别：</strong></p><p>正向代理：让服务器不知道他服务的对象是谁（用户请了代理），常见的应用就是VPN，假如大家想在大学校外访问校园内网，通常要使用学校提供的VPN，让校内的服务器给代理服务，然后代理再把收到的信息转给你。</p><p>反向代理：让用户不知道谁在为他服务（服务器请了代理）。以前给10086打电话，它的客服有很多，你打进来的电话会随机转接到某个客服上，这个转接过程就是反向代理，用户知道的就是10086这个“代理”，而实际给你服务的客服是不知道的。</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>一台云主机（Linux系统为例 测试用ubuntu 18系统）</li><li>一个域名（可以不用备案）（可选）</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="域名解析（可选）"><a href="#域名解析（可选）" class="headerlink" title="域名解析（可选）"></a>域名解析（可选）</h3><p>打开域名管理页面，添加*.ngrok.example.com和ngrok.example.com两条记录</p><p>到时候你将通过 xxx.ngrok.example.com:端口 来访问代理服务器</p><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs console">apt-get update  # 更新软件列表<br>apt-get upgrade  # 更新软件<br>apt install git  # 获取git<br><br>git --version  # 检查已安装git版本<br></code></pre></td></tr></table></figure><h3 id="安装、配置go语言环境"><a href="#安装、配置go语言环境" class="headerlink" title="安装、配置go语言环境"></a>安装、配置go语言环境</h3><p>打开<a href="https://studygolang.com/dl">go语言中文网</a>找到最新的go版本（这里以1.14为例），然后用wget下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://studygolang.com/dl/golang/go1.14.linux-amd64.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 默认下载到当前目录，使用 -P path 参数可以指定下载路径</span><br>tar -zxvf go1.14.linux-amd64.tar.gz<br><span class="hljs-meta">#</span><span class="bash"> 默认解压到当前目录</span><br>mv go /usr/local<br><span class="hljs-meta">#</span><span class="bash"> 将go挪到另一个目录，方便管理</span><br><br>cd ~<br><span class="hljs-meta">#</span><span class="bash"> 到主目录</span><br>vi .bashrc<br><span class="hljs-meta">#</span><span class="bash"> 打开配置文件,在末尾添加如下</span><br>export GOROOT=/usr/local/go<br><span class="hljs-meta">#</span><span class="bash"> 这个目录是go的解压目录</span><br>export GOPATH=/home/gosrc/ngrok<br><span class="hljs-meta">#</span><span class="bash"> 这个目录是go的工作目录，即等下要编译ngrok的目录</span><br>export PATH=$GOROOT/bin:$PATH:$GOPATH/bin<br><span class="hljs-meta">#</span><span class="bash"> 设置bin目录</span><br>:wq<br><span class="hljs-meta">#</span><span class="bash"> 保存并退出</span><br>source .bashrc<br><span class="hljs-meta">#</span><span class="bash"> 生效</span><br><br>go version<br><span class="hljs-meta">#</span><span class="bash"> 查看go是否成功安装</span><br></code></pre></td></tr></table></figure><h2 id="安装ngrok"><a href="#安装ngrok" class="headerlink" title="安装ngrok"></a>安装ngrok</h2><h3 id="下载ngrok"><a href="#下载ngrok" class="headerlink" title="下载ngrok"></a>下载ngrok</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /home/gosrc/ngrok<br><span class="hljs-meta">#</span><span class="bash"> 进入你自己准备用来编译的ngrok工作区</span><br>git clone https://github.com/inconshreveable/ngrok.git<br><span class="hljs-meta">#</span><span class="bash"> 把库<span class="hljs-built_in">clone</span>下来</span><br></code></pre></td></tr></table></figure><h3 id="生成签名证书"><a href="#生成签名证书" class="headerlink" title="生成签名证书"></a>生成签名证书</h3><p>这一步很重要，也很容易错，我们要生成自己的SSL证书。</p><p>由于我计划最终提供服务的地址是xxx.ngrok.example.com所以我把NGROK_DOMAIN设置如下</p><p><strong>注意把域名设置成你自己的域名</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">NGROK_DOMAIN=&quot;ngrok.example.com&quot;<br> <br>openssl genrsa -out rootCA.key 2048<br>openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -days 5000 -out rootCA.pem<br>openssl genrsa -out server.key 2048<br>openssl req -new -key server.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out server.csr<br>openssl x509 -req -in server.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out server.crt -days 5000<br> <br>cp rootCA.pem assets/client/tls/ngrokroot.crt<br>cp device.crt assets/server/tls/snakeoil.crt<br>cp device.key assets/server/tls/snakeoil.key<br></code></pre></td></tr></table></figure><p>最后三个cp命令是将生成的证书覆盖原来ngrok的证书</p><h3 id="编译ngrok"><a href="#编译ngrok" class="headerlink" title="编译ngrok"></a>编译ngrok</h3><p>最容易出问题的一步</p><p><strong>编译Linux服务端（本机）</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOOS=linux GOARCH=386 make release-server<br><span class="hljs-meta">#</span><span class="bash"> 32位</span><br>GOOS=linux GOARCH=amd64 make release-server<br><span class="hljs-meta">#</span><span class="bash"> 64位</span><br></code></pre></td></tr></table></figure><p><strong>编译windows客户端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOOS=windows GOARCH=amd64 make release-client<br><span class="hljs-meta">#</span><span class="bash"> 64位，没人用32了吧。。。</span><br></code></pre></td></tr></table></figure><p><strong>编译Linux客户端</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOOS=linux GOARCH=386 make release-client<br><span class="hljs-meta">#</span><span class="bash"> 32位</span><br>GOOS=linux GOARCH=amd64 make release-client<br><span class="hljs-meta">#</span><span class="bash"> 64位</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>go-bindata的错误解决</strong></p><p>go get github.com/go-bindata/go-bindata/…</p><p>按道理会出现在GOPATH，然后把go-bindata复制到ngrok/bin下面</p></blockquote><blockquote><p><strong>其他错误解决</strong></p><p>检查你的云主机是否能正常访问网络</p><p>检查GOPATH的设置，看看是否正确</p><p><code>echo $GOPATH</code></p></blockquote><p>假如一切正常，那么在bin目录下会出现ngrokd（Linux客户端），还可能有存有exe文件的目录</p><h2 id="启动服务端"><a href="#启动服务端" class="headerlink" title="启动服务端"></a>启动服务端</h2><p>在ngrok目录运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bin/ngrokd -tlsKey=server.key -tlsCrt=server.crt -domain=&quot;ngrok.example.com&quot; -httpAddr=&quot;:8090&quot;<br></code></pre></td></tr></table></figure><p>前两个参数是指定证书；第三个参数是域名；第四个参数是用来转发http的端口，可以随便写；还可以写httpsAddr用来指定转发https的端口</p><h2 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h2><p>用ftp或者其他方法，将客户端的ngrok或ngrok.exe放到要被访问的机器上</p><ul><li><strong>新建一个ngrok.cfg，打开写入如下内容</strong></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server_addr:</span> <span class="hljs-string">&quot;ngrok.example.com:4443&quot;</span><br><span class="hljs-attr">trust_host_root_certs:</span> <span class="hljs-literal">false</span><br><span class="hljs-attr">tunnels:</span><br> <span class="hljs-attr">a:</span><br>  <span class="hljs-attr">remote_port:</span> <span class="hljs-number">12345</span><br>  <span class="hljs-attr">proto:</span><br>   <span class="hljs-attr">tcp:</span> <span class="hljs-string">&quot;127.0.0.1:25565&quot;</span><br>   <span class="hljs-attr">tcp:</span> <span class="hljs-string">&quot;127.0.0.1:25566&quot;</span><br> <span class="hljs-attr">b:</span><br>  <span class="hljs-attr">proto:</span><br>   <span class="hljs-attr">http:</span> <span class="hljs-string">&quot;127.0.0.1:80&quot;</span><br></code></pre></td></tr></table></figure><p>此文件位YAML格式，<strong>缩进用空格</strong>。</p><p><code>server_addr</code>后填写你的域名，要和之前写的一模一样。</p><p>4443是固定端口，一般不改，但也可以在服务端更改。</p><p>tunnels允许配置文件配置多个隧道，<strong>可以同时启动多个隧道</strong>。</p><p>a和b是隧道名字。</p><p>a中<code>remote_port</code>是远程端口，即访问 <code>xxx.ngrok.example.com:端口</code> 时要输入的端口，假如是http协议则此项无效</p><p>proto是隧道协议，在之下可以<strong>同时用不同协议暴露不同局域网ip地址和端口</strong></p><ul><li><strong>新建一个 启动.bat ，打开写入如下内容</strong></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ngrok -subdomain test -config=ngrok.cfg start a<br></code></pre></td></tr></table></figure><p><code>-subdomain</code>是确定你要用什么三级域名来访问，就是上面xxx的内容。</p><p><code>-config</code>确定配置文件。</p><p><code>start</code>启动隧道，可以<code>start a b c d</code>。</p><p><code>ngrok help</code>可以查看帮助</p><ul><li><strong>双击bat文件运行</strong></li></ul><p>假如出现绿色的online就开启成功。</p><blockquote><p>闪退错误解决</p><ul><li>bat和cfg是否写错</li><li>云主机响应端口是否开放（阿里云服务器要在安全组中设置端口）</li><li>观察服务端的ngrokd输出，假如出现bad certificate，那么就是证书错误，检查你的客户端版本以及服务端用的证书是否统一</li></ul></blockquote><h2 id="Linux后台运行服务端"><a href="#Linux后台运行服务端" class="headerlink" title="Linux后台运行服务端"></a>Linux后台运行服务端</h2><p>由于断开ssh连接后就导致穿透关闭，所以要用<code>screen</code>来后台运行</p><p><strong>安装screen</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install screen<br></code></pre></td></tr></table></figure><p><strong>screen命令</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">screen -S name<br><span class="hljs-meta">#</span><span class="bash"> 新建一个名字叫name的screen</span><br>screen<br><span class="hljs-meta">#</span><span class="bash"> 新建一个没有名字的screen</span><br>screen -ls<br><span class="hljs-meta">#</span><span class="bash"> 查看当前有多少个screen以及信息</span><br><span class="hljs-meta">#</span><span class="bash"> 结果有Dead：死了 Detached：独立的screen Attched：</span><br>screen -r name|id<br><span class="hljs-meta">#</span><span class="bash"> 通过name或者id来恢复screen</span><br>ctrl+a d<br><span class="hljs-meta">#</span><span class="bash"> 先按ctrl+a 再按d 分离screen，退出到主窗口</span><br>ctrl+a k<br><span class="hljs-meta">#</span><span class="bash"> 杀死当前screen</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ngrok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python Logging模块</title>
    <link href="/2021/03/03/Python-Logging-module/"/>
    <url>/2021/03/03/Python-Logging-module/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Logging类"><a href="#Python-Logging类" class="headerlink" title="Python Logging类"></a>Python Logging类</h1><p>Python的Logging类是专门成立程序日志的类，能够方便的输出日志到屏幕、文件等多个地方，能够方便控制如何输出，还能够设置消息级别。</p><ul><li>Logging.Logger：Logger是Logging模块的主体，为程序提供记录日志接口、判断级别、分配给handler。这个对象<strong>不能实例</strong>，应该通过getLogger()来获取。</li><li>Logging.Handler：Handler基于日志级别对日志进行分发，如设置为WARNING级别的Handler只会处理WARNING及以上级别的日志。</li><li>Logging.Filter：Filter是过滤器，可以提供更高级的自定义过滤方式。</li><li>Logging.Formatter: 这个类处理输出格式</li></ul><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/486223_1_En_27_Figa_HTML.png" alt="Logging的结构图"></p><h2 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h2><p><strong>级别排序:  CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG</strong></p><p>使用方法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.debug(<span class="hljs-string">&quot;张三&quot;</span>)<br>logging.info(<span class="hljs-string">&quot;李四&quot;</span>)<br>logging.warning(<span class="hljs-string">&quot;王五&quot;</span>)<br>logging.error(<span class="hljs-string">&quot;小明&quot;</span>)<br>logging.critical(<span class="hljs-string">&quot;小红&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/QQ%E6%88%AA%E5%9B%BE20200427181133.png" alt="log在控制台的输出"></p><p>默认只显示WARING级别以上。下面代码实现自定义输出级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(level=logging.NOTSET)  <span class="hljs-comment"># NOTSET是最低等级</span><br></code></pre></td></tr></table></figure><p>注意！：This function does nothing if the root logger already has handlers configured, unless the keyword argument <em>force</em> is set to <code>True</code>.</p><p>若不使用force参数，则设置输出级别只有第一次有效。<code>force=true</code>能在执行其他参数指定的配置之前，将移除并关闭附加到根记录器的所有现有处理器。</p><p>有一个特殊的日志输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">logger.exception(<span class="hljs-string">&quot;Failed to open sklearn.txt from logger.exception&quot;</span>)<br><span class="hljs-comment"># 这个的输出是traceback的信息</span><br><span class="hljs-comment">#Failed to open sklearn.txt from logger.exception</span><br><span class="hljs-comment">#Traceback (most recent call last):</span><br><span class="hljs-comment">#  File &quot;G:\zhb7627\Code\Eclipse WorkSpace\PythonTest\test.py&quot;, line 23, in &lt;module&gt;</span><br><span class="hljs-comment">#    open(&quot;sklearn.txt&quot;,&quot;rb&quot;)</span><br><span class="hljs-comment">#IOError: [Errno 2] No such file or directory: &#x27;sklearn.txt&#x27;</span><br><br><span class="hljs-comment"># 也可以通过指定参数实现</span><br><span class="hljs-comment"># 下面这条语句和上面等价</span><br>logger.error(<span class="hljs-string">&quot;Faild to open sklearn.txt from logger.error&quot;</span>,exc_info = <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h2 id="设置输出格式"><a href="#设置输出格式" class="headerlink" title="设置输出格式"></a>设置输出格式</h2><p>格式有以下几种</p><ul><li>%(levelno)s: 打印日志级别的数值</li><li>%(levelname)s: 打印日志级别名称</li><li>%(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]</li><li>%(filename)s: 打印当前执行程序名，如：login.py</li><li>%(funcName)s: 打印日志的当前函数</li><li>%(lineno)d: 打印日志的当前行号,在第几行打印的日志</li><li>%(asctime)s: 打印日志的时间</li><li>%(thread)d: 打印线程ID</li><li>%(threadName)s: 打印线程名称</li><li>%(process)d: 打印进程ID</li><li>%(message)s: 打印日志信息</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过basicConfig来设置格式</span><br><span class="hljs-comment"># basicConfig是默认配置</span><br><span class="hljs-comment"># format是上面的格式字符串</span><br><span class="hljs-comment"># datefmt是和time.strftime()一样的格式字符串</span><br>logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>，<br>datefmt=<span class="hljs-string">&#x27;%a, %d %b %Y %H:%M:%S&#x27;</span>，<br>)<br></code></pre></td></tr></table></figure><p>注意输出格式在Windows下和Linux下都要符合命名规则。</p><h2 id="日志输出到文件和控制台"><a href="#日志输出到文件和控制台" class="headerlink" title="日志输出到文件和控制台"></a>日志输出到文件和控制台</h2><p>接下来是高级用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging  <span class="hljs-comment"># 引入logging模块</span><br><span class="hljs-comment"># 第一步，创建一个logger</span><br>logger = logging.getLogger()<br>logger.setLevel(logging.INFO)   <span class="hljs-comment"># Log等级总开关</span><br><span class="hljs-comment"># 第二步，创建一个FileHandler，用于写入日志文件</span><br>handler = logging.FileHandler(<span class="hljs-string">&quot;log.txt&quot;</span>)  <span class="hljs-comment"># 文件名字</span><br>handler.setLevel(logging.INFO)  <span class="hljs-comment"># 单独handler的log等级设置 </span><br><span class="hljs-comment"># 第三步，设置filehandler的格式</span><br>formatter = logging.Formatter(<span class="hljs-string">&#x27;%(asctime)s - %(name)s - %(levelname)s - %(message)s&#x27;</span>)<br>handler.setFormatter(formatter)<br><span class="hljs-comment"># 第四步，创建StreamHandler，用于输出到控制台</span><br>console = logging.StreamHandler()<br>console.setLevel(logging.INFO)  <span class="hljs-comment"># 单独handler的log等级设置</span><br><span class="hljs-comment"># 第六步，设置StreamHandler的格式</span><br>console.setFormatter(formatter)<br><span class="hljs-comment"># 第五步，添加handler到logger</span><br>logger.addHandler(handler)<br>logger.addHandler(console)<br><br><span class="hljs-comment"># 日志</span><br>logger.debug(<span class="hljs-string">&#x27;this is a logger debug message&#x27;</span>)<br>logger.info(<span class="hljs-string">&#x27;this is a logger info message&#x27;</span>)<br>logger.warning(<span class="hljs-string">&#x27;this is a logger warning message&#x27;</span>)<br>logger.error(<span class="hljs-string">&#x27;this is a logger error message&#x27;</span>)<br>logger.critical(<span class="hljs-string">&#x27;this is a logger critical message&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="logging-getLogger"><a href="#logging-getLogger" class="headerlink" title="logging.getLogger()"></a>logging.getLogger()</h2><p>这个方法返回一个Logger对象，参数是Logger的名字，get相同名字会返回相同的logger，在不同模块要调用logger的时候永远都不需要传递logger参数，只需要使用这个方法即可。</p><p>示例：<code>logging,getLogger(&quot;hahahaha&quot;)</code></p><p>Logger的名字可以体现继承关系，用<code>.</code>来分隔，子logger继承父logger的配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.getLogger(<span class="hljs-string">&quot;PythonApp&quot;</span>)<br><br>logging.getLogger(<span class="hljs-string">&quot;PythonApp.Core&quot;</span>)  <span class="hljs-comment"># 继承PythonApp的配置</span><br>logging.getLogger(<span class="hljs-string">&quot;PythonApp.Web&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="logging-Filter"><a href="#logging-Filter" class="headerlink" title="logging.Filter"></a>logging.Filter</h2><p>需要定义一个新的类来自定义过滤规则</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoParsingFilter</span>(<span class="hljs-params">logging.Filter</span>):</span>  <span class="hljs-comment"># 继承logging.Filter</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter</span>(<span class="hljs-params">self, record</span>):</span>  <span class="hljs-comment"># 重写filter</span><br>    <span class="hljs-keyword">if</span> record.name == <span class="hljs-string">&#x27;PythonApp&#x27;</span> <span class="hljs-keyword">and</span> record.levelno == logging.INFO:<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  <span class="hljs-comment"># 返回True False来控制是否过滤</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>logger = logging.getLogger(<span class="hljs-string">&#x27;PythonApp&#x27;</span>)<br>logger.addFilter(NoParsingFilter())<br>logger.info(<span class="hljs-string">&quot;info&quot;</span>)<br>logger.error(<span class="hljs-string">&quot;error&quot;</span>)<br></code></pre></td></tr></table></figure><p>record是logging.LogRecord类，有以下属性：</p><ul><li><p>name logger的名字</p></li><li><p>levelno是级别</p></li><li><p>levelname是级别的字符串</p></li><li><p>pathname 是哪个文件输出的这行日志</p></li><li><p>lineno 是行号</p></li><li><p>msg 是日志本身</p></li><li><p>除此以外还有formatter格式化字符串的所有属性</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.cnblogs.com/xianyulouie/p/11041777.html">python中logging日志模块详解 - 咸鱼也是有梦想的 - 博客园 (cnblogs.com)</a></p><p><a href="https://www.jb51.net/article/165534.htm">使用Filter过滤python中的日志输出的实现方法</a></p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Logging</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python多线程详解（真的很详细）</title>
    <link href="/2021/03/01/Python-Multithreading-in-detail/"/>
    <url>/2021/03/01/Python-Multithreading-in-detail/</url>
    
    <content type="html"><![CDATA[<h1 id="Python多线程详解"><a href="#Python多线程详解" class="headerlink" title="Python多线程详解"></a>Python多线程详解</h1><p>使用多线程，可以同时进行多项任务，可以使用户界面更友好，还可以后台执行某些用时长的任务，同时具有易于通信的优点。（对于GIL以及Python多线程对于效率的影响讨论可看知乎<a href="https://www.zhihu.com/question/23474039">为什么有人说 Python 的多线程是鸡肋呢？ - 知乎 (zhihu.com)</a>）</p><p>Python3中使用的是threading模块。</p><h2 id="创建和执行一个线程"><a href="#创建和执行一个线程" class="headerlink" title="创建和执行一个线程"></a>创建和执行一个线程</h2><p>一般我们有两种方法来创建线程，一种是以某个函数来作为起点，另一种是继承Thread类。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>获取一个Thread对象，构造参数中target是起点函数，注意不要加括号。假如起点函数有参数，则可以通过args输入元组参数或者kwargs输入字典参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始做一个任务啦&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 用time.sleep模拟任务耗时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个任务结束啦&quot;</span>)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这里是主线程&quot;</span>)<br>    <span class="hljs-comment"># 创建线程对象</span><br>    t1 = Thread(target=task)<br>    <span class="hljs-comment"># 启动</span><br>    t1.start()<br>    time.sleep(<span class="hljs-number">0.3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程依然可以干别的事&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301190927.png" alt="1.png"></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewThread</span>(<span class="hljs-params">Thread</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        Thread.__init__(self)  <span class="hljs-comment"># 必须步骤</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span>  <span class="hljs-comment"># 入口是名字为run的方法</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始做一个任务啦&quot;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 用time.sleep模拟任务耗时</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这个任务结束啦&quot;</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这里是主线程&quot;</span>)<br>    <span class="hljs-comment"># 创建线程对象</span><br>    t1 = NewThread()<br>    <span class="hljs-comment"># 启动</span><br>    t1.start()<br>    time.sleep(<span class="hljs-number">0.3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程依然可以干别的事&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="正式介绍threading模块"><a href="#正式介绍threading模块" class="headerlink" title="正式介绍threading模块"></a>正式介绍threading模块</h2><p>关于线程信息的函数：</p><ul><li><code>threading.active_count()</code>：返回当前存活的Thread对象数量。</li><li><code>threading.current_thread()</code>：返回当前线程的Thread对象。</li><li><code>threading.enumerate()</code>：列表形式返回所有存活的Thread对象。</li><li><code>threading.main_thread()</code>：返回主Thread对象。</li></ul><p>Thread对象的方法及属性：</p><ul><li><code>Thread.name</code>：线程的名字，没有语义，可以相同名称。</li><li><code>Thread.ident</code>：线程标识符，非零整数。</li><li><code>Thread.Daemon</code>：是否为守护线程。</li><li><code>Thread.is_alive()</code>：是否存活。</li><li><code>Thread.start()</code>：开始线程活动。若多次调用抛出RuntimeError。</li><li><code>Thread.run()</code>：用来重载的，</li><li><code>Thread.join(timeout=None)</code>：等待直到线程正常或异常结束。尚未开始抛出RuntimeError</li><li><code>Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, deamon=None)</code>：构造函数。</li></ul><h3 id="守护线程-Daemon"><a href="#守护线程-Daemon" class="headerlink" title="守护线程 Daemon"></a>守护线程 Daemon</h3><p>如果某个线程是守护线程，那么这个线程会在主线程运行完毕后结束。<em>主线程运行完毕指的是主线程的进程内所有非守护线程全部运行完毕，所以可以理解为守护进程是不那么重要的进程。</em></p><p>设置守护线程用Thread.setDaemon(bool)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task1</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始做任务1啦&quot;</span>)<br>    time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 用time.sleep模拟任务耗时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1结束啦&quot;</span>)<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task2</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始做任务2啦&quot;</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2-&#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(i))<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务2结束啦&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这里是主线程&quot;</span>)<br>    <span class="hljs-comment"># 创建线程对象</span><br>    t1 = Thread(target=task1)<br>    t2 = Thread(target=task2)<br>    t2.setDaemon(<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 设置为守护进程，必须在start之前</span><br>    <span class="hljs-comment"># 启动</span><br>    t1.start()<br>    t2.start()<br>    time.sleep(<span class="hljs-number">0.3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程结束了&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191003.png" alt="2"></p><p>运行这段代码用IDLE可能出现守护进程未结束的bug，所以用pycharm或者在命令行里运行可看见真实效果。</p><p><a href="https://www.zhihu.com/question/26826953">关于这个bug的讨论</a></p><h3 id="让主线程等待子线程结束-join"><a href="#让主线程等待子线程结束-join" class="headerlink" title="让主线程等待子线程结束 join"></a>让主线程等待子线程结束 join</h3><p>假如要让主线程等子线程，那么可以使用Thread.join()方法。</p><p>join可以让运行这条语句的主线程在此阻塞（等待），直到子线程结束，再放行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task1</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开始做任务1啦&quot;</span>)<br>    time.sleep(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 用time.sleep模拟任务耗时</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;任务1结束啦&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这里是主线程&quot;</span>)<br>    <span class="hljs-comment"># 创建线程对象</span><br>    t1 = Thread(target=task1)<br>    <span class="hljs-comment"># t1.setDaemon(True)  # 设置为守护进程，必须在start之前</span><br>    <span class="hljs-comment"># 启动</span><br>    t1.start()<br>    <span class="hljs-comment"># 阻塞</span><br>    t1.join()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程结束了&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191050.png" alt="4"></p><h2 id="由于线程共享资源而引发的bug"><a href="#由于线程共享资源而引发的bug" class="headerlink" title="由于线程共享资源而引发的bug"></a>由于线程共享资源而引发的bug</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread<br><br>n=<span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task1</span>():</span><br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">800000</span>):  <span class="hljs-comment"># 将n循环加800000</span><br>        n += <span class="hljs-number">1</span><br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task2</span>():</span><br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;n is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(n))  <span class="hljs-comment"># 访问n</span><br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这里是主线程&quot;</span>)<br>    <span class="hljs-comment"># 创建线程对象</span><br>    t1 = Thread(target=task1)<br>    t2 = Thread(target=task2)<br>    <span class="hljs-comment"># 启动</span><br>    t1.start()<br>    t2.start()<br>    time.sleep(<span class="hljs-number">0.3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程结束了&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191108.png" alt="3"></p><p>你的结果很可能与我不同，多次执行这个代码的结果也很可能不同。由于这种不确定性，程序有可能出现致命错误，我们称之为<strong>线程不安全</strong>。</p><p>这个问题出现的原因是这样的：t1线程启动后，循环很多次，每次将全局变量n加1，但是加这么多次是要时间的，在t1没有将n加完时，t2线程就对n进行了访问，从而访问到的值可能不是期望值。</p><p><strong>线程安全</strong>的类应该具有以下特征：</p><ul><li>该类的对象可以被多个线程安全地访问</li><li>每个线程在调用该对象的任意方法后，都将得到正确的结果</li><li>每个线程在调用该对象的任意方法后，该对象都依然保持合理的状态</li></ul><p>接下来我们将采取一定的方法来使线程安全。</p><h3 id="锁-Lock-重入锁-RLock"><a href="#锁-Lock-重入锁-RLock" class="headerlink" title="锁 Lock  重入锁 RLock"></a>锁 Lock  重入锁 RLock</h3><p>锁是保证线程安全的一种途径，你可以想象全局变量都存放在一个房间里，只有进入这个房间的人（线程）才能操作全局变量，在许多人进房间的时候，就可能出现混乱。因此他们约定，在门口挂一个牌子，一面写着有人，另一面写着没人，每当有人进出的时候就把牌子翻一面，别人看见这牌子是有人就在门口等着。（这就是锁的获取与释放）。然而既然是约定，就能被打破，有的人可能不知道这个约定，牌子上写着有人他也会进去。（这就是执行没有写锁部分的的方法的线程）</p><p>Python的threading模块中有<strong>Lock</strong>和<strong>RLock</strong>两个类。他们都有这两个方法</p><p><code>Lock.acquire(blocking=True, timeout=-1)</code> 获取锁。</p><ul><li>获取成功返回True，超时或其他返回False</li></ul><ul><li><p>timeout参数指定获取不到锁时等待的时间，单位为秒。</p></li><li><p>blocking参数指定是否阻塞调用，默认获取不到锁就阻塞。</p></li></ul><p><code>Lock.release()</code> 释放锁。</p><ul><li><p>对于Lock，可以从任何线程调用，不一定是上锁的那个线程才能解锁。</p></li><li><p>对于RLock，只能从上锁的线程调用。</p></li></ul><ul><li>对未锁定的锁调用release会引发RuntimeError</li></ul><p><strong>RLock</strong>的R表示Reentrant，如果用RLock，那么在同一个线程中可以对它多次acquire，同时也要用相同数目的release来释放锁。这个东西的意义在于避免<strong>死锁</strong>。</p><blockquote><p>死锁（Deadlock）是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></blockquote><p>举个例子，假如你要使用递归函数，这个递归函数中需要对某个全局变量修改，于是你加上了Lock，然而在递归的过程中，第二层递归的acquire就获取不到锁了，于是第一层递归在等待第二层结束，而第二层在等待第一层的release，这就造成了死锁。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191118.jpeg" alt="死锁"></p><p><strong>使用锁可能导致执行速度慢，但是保证了线程安全</strong></p><p>无论是Lock还是RLock，acquire和release都要成对出现，所以一般用这种形式写语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">lock.acquire()<br><span class="hljs-keyword">try</span>:<br><span class="hljs-comment"># do something</span><br><span class="hljs-keyword">finally</span>:<br>lock.release()<br></code></pre></td></tr></table></figure><p>使用Lock改进上一次代码的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, Lock<br><br>lock = Lock()  <span class="hljs-comment"># 创建锁对象</span><br>n=<span class="hljs-number">0</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task1</span>():</span><br>    <span class="hljs-keyword">global</span> n<br>    <span class="hljs-keyword">global</span> lock<br>    lock.acquire()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">800000</span>):<br>        n += <span class="hljs-number">1</span><br>    lock.release()<br>    <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task2</span>():</span><br>    <span class="hljs-keyword">global</span> n<br>    lock.acquire()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;task2: n is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(n))<br>    lock.release()<br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;这里是主线程&quot;</span>)<br>    <span class="hljs-comment"># 创建线程对象</span><br>    t1 = Thread(target=task1)<br>    t2 = Thread(target=task2)<br>    <span class="hljs-comment"># 启动</span><br>    t1.start()<br>    t2.start()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;main: n is &#123;&#125;&quot;</span>.<span class="hljs-built_in">format</span>(n))  <span class="hljs-comment"># 未使用lock的线程仍然访问到错误数据</span><br>    time.sleep(<span class="hljs-number">0.3</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;主线程结束了&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191135.png" alt="7"></p><h3 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列 Queue"></a>队列 Queue</h3><p>Python的queue模块为单独的一个模块，并不在threading里。Queue模拟各种不同的队列，使不同线程之间实现<strong>松耦合</strong>，并且提高效率，经常使用它。</p><p>Python中的queue有三种队列，分别是<code>queue.Queue()</code> <code>queue.LifoQueue()</code> <code>queue.PriorityQueue()</code></p><p><strong>Queue</strong>就是FIFO(First In First Out)先入先出队列。</p><p><strong>LifoQueue</strong>是LIFO(Last In First Out)后入先出队列，对应栈数据结构。</p><p><strong>PriorityQueue</strong>需要你指定添加进队列的数据的重要性，然后队列根据重要性排序，更小的先出。</p><blockquote><p>官方文档：</p><p>最小值先被取出( 最小值条目是由 <code>sorted(list(entries))[0]</code> 返回的条目)。条目的典型模式是一个以下形式的元组： <code>(priority_number, data)</code> 。</p></blockquote><p>也就是说你向PriorityQueue中添加数据时，推荐采用 <code>(priority_number, data)</code> 格式，元组的第一个数据代表优先级，数字越小越先（可以是负数），假如优先级相同，会比较第二个数据，假如不可比较会报错。假如前两个数据都相等，则顺序随机。</p><p>Queue是父类，下面介绍Queue的方法：</p><p><code>Queue(maxsize)</code> 实例化Queue类可提供队列最大值的参数。到达最大值之后的put操作会阻塞。</p><p><code>Queue.put(block=True, timeout=None)</code> 向队列中添加一个数据，同样可以设置阻塞等待时长。超时直接抛出<code>queue.Full</code>错误。</p><p><code>Queue.get(block=True, timeout=None)</code> 从队列中获取一个数据，并从中删除这个数据，超时抛出<code>queue.Empty</code>错误。不设置超时会一直堵塞。</p><p><code>Queue.qsize()</code> 返回队列中数据的量，不怎么可靠，因为获取的同时，其他线程可能进行操作。</p><p><code>Queue.join() </code>队列还存在未完成任务时阻塞，等待知道队列无未完成任务。<strong>注意是任务完成而不是队列为空，需要与task_done联合使用</strong></p><p><code>Queue.task_done()</code> 每put一个数据就会让未完成任务+1，<strong>但是get不会-1</strong>，只有task_done才会-1</p><p>队列为空时报错<code>ValueError</code></p><h4 id="用Queue完成生产者-消费者模型（吃货版）"><a href="#用Queue完成生产者-消费者模型（吃货版）" class="headerlink" title="用Queue完成生产者-消费者模型（吃货版）"></a>用Queue完成生产者-消费者模型（吃货版）</h4><p>生产者消费者模型是一种松耦合模型，生产者互相之间不需要沟通，消费者之间也不需要沟通，生产者和消费者只关系仓库，也就是这里的queue。生产者将数据放入容器，数据流向消费者，消费者从容器中取出数据。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191148.jpeg" alt="模型图"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, current_thread<br><span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue,Empty<br><br>foods = (<span class="hljs-string">&quot;蒸羊羔&quot;</span>,<span class="hljs-string">&quot;蒸熊掌&quot;</span>,<span class="hljs-string">&quot;蒸鹿尾儿&quot;</span>,<span class="hljs-string">&quot;烧花鸭&quot;</span>,<span class="hljs-string">&quot;烧雏鸡&quot;</span>,<span class="hljs-string">&quot;烧子鹅&quot;</span>,<br>        <span class="hljs-string">&quot;卤猪&quot;</span>,<span class="hljs-string">&quot;卤鸭&quot;</span>,<span class="hljs-string">&quot;酱鸡&quot;</span>,<span class="hljs-string">&quot;腊肉&quot;</span>,<span class="hljs-string">&quot;松花&quot;</span>,<span class="hljs-string">&quot;小肚儿&quot;</span>,<span class="hljs-string">&quot;晾肉&quot;</span>,<span class="hljs-string">&quot;香肠&quot;</span>,<br>        <span class="hljs-string">&quot;什锦苏盘&quot;</span>,)  <span class="hljs-comment"># 食物列表</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">producer</span>(<span class="hljs-params">queue</span>):</span>  <span class="hljs-comment"># 生产者</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[&#123;&#125;]厨师来了&#x27;</span>.<span class="hljs-built_in">format</span>(current_thread().name))  <br>    <span class="hljs-comment"># current_thread()返回一个Thread对象，其有一个name属性，表示线程的名字</span><br>    <span class="hljs-keyword">global</span> foods<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):  <span class="hljs-comment"># 上十道菜，每道菜加工0.8s</span><br>        food = random.choice(foods)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[&#123;&#125;]正在加工&#123;&#125;中.....&#x27;</span>.<span class="hljs-built_in">format</span>(current_thread().name,food))<br>        time.sleep(<span class="hljs-number">0.8</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[&#123;&#125;]上菜了...&#x27;</span>.<span class="hljs-built_in">format</span>(current_thread().name))<br>        queue.put(food)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">consumer</span>(<span class="hljs-params">queue</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[&#123;&#125;]客人来了&#x27;</span>.<span class="hljs-built_in">format</span>(current_thread().name))<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-comment"># 每道菜吃0.5s，等上菜的耐心是0.5s</span><br>        <span class="hljs-keyword">try</span>:<br>            food = queue.get(timeout=<span class="hljs-number">0.5</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[&#123;&#125;]正在享用美食:&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(current_thread().name,food))<br>            time.sleep(<span class="hljs-number">0.5</span>)<br>        <span class="hljs-keyword">except</span> Empty:  <span class="hljs-comment"># get不到会抛出Empty</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;没菜吃了，[&#123;&#125;]走了&quot;</span>.<span class="hljs-built_in">format</span>(current_thread().name))<br>            <span class="hljs-keyword">break</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    queue = Queue()<br>    pds = []  <span class="hljs-comment"># 生产者列表</span><br>    csm = []  <span class="hljs-comment"># 消费者列表</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        t = Thread(target=producer, args=(queue,))  <span class="hljs-comment"># 由于参数是元组，所以末尾加逗号</span><br>        t.start()<br>        pds.append(t)<br>    time.sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>):<br>        t = Thread(target=consumer, args=(queue,))<br>        t.start()<br>        csm.append(t)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191156.png" alt="8"></p><h2 id="线程池-thread-pool"><a href="#线程池-thread-pool" class="headerlink" title="线程池  thread pool"></a>线程池  thread pool</h2><p>虽然线程比进程简单许多，但是系统启动一个新线程的成本依旧很高。线程池创建时会<strong>自动创建</strong>一定空闲的线程，我们将一个函数（任务）提交给线程池，线程池就会调用一个空闲的进程来执行它，当函数结束时，线程不死亡，而是返回到线程池中等待执行下一个函数（任务）。</p><p><strong>当程序中需要创建大量生存期短暂的线程时，可考虑线程池</strong></p><p><strong>当程序中需要控制并发线程时，可考虑线程池</strong></p><p>python中有<strong>concurrent.futures</strong>模块，线程池的基类是Executor，其有两个子类，即 <strong>ThreadPoolExecutor</strong> 和 <strong>ProcessPoolExecutor</strong>，其中 <strong>ThreadPoolExecutor</strong> 用于创建线程池，而 <strong>ProcessPoolExecutor</strong> 用于创建进程池。</p><p><strong>Exectuor</strong> 提供了如下常用方法：</p><ul><li><code>submit(fn, *args, **kwargs)</code>：将 fn 函数提交给线程池。<em>args 代表传给 fn 函数的参数，</em>kwargs 代表以关键字参数的形式为 fn 函数传入参数。</li><li><code>map(func, *iterables, timeout=None, chunksize=1)</code>：该函数类似于全局函数 <code>map(func, *iterables)</code>，只是该函数将会启动多个线程，以异步方式立即对 iterables 执行 map 处理。超时抛出TimeoutError错误。返回每个函数的结果，<strong>注意不是返回future</strong>。</li><li><code>shutdown(wait=True)</code>：关闭线程池。关闭之后线程池不再接受新任务，但会将之前提交的任务完成。</li></ul><p>程序将task函数submit给线程池后，会返回一个Future对象，Future主要用来获取task的返回值。</p><blockquote><p>由于结果不确定，对于当时是的未来的对象，所以取名future。</p></blockquote><p><strong>Future</strong> 提供了如下方法：</p><ul><li><code>cancel()</code>：取消该 Future 代表的线程任务。如果该任务正在执行，不可取消，则该方法返回 False；否则，程序会取消该任务，并返回 True。</li><li><code>cancelled()</code>：返回 Future 代表的线程任务是否被成功取消。</li><li><code>running()</code>：如果该 Future 代表的线程任务正在执行、不可被取消，该方法返回 True。</li><li><code>done()</code>：如果该 Funture 代表的线程任务被成功取消或执行完成，则该方法返回 True。</li><li><code>result(timeout=None)</code>：获取该 Future 代表的线程任务最后返回的结果。如果 Future 代表的线程任务还未完成，该方法将会阻塞当前线程，其中 timeout 参数指定最多阻塞多少秒。超时抛出TimeoutError，取消抛出CancelledError。</li><li><code>exception(timeout=None)</code>：获取该 Future 代表的线程任务所引发的异常。如果该任务成功完成，没有异常，则该方法返回 None。</li><li><code>add_done_callback(fn)</code>：为该 Future 代表的线程任务注册一个“回调函数”，当该任务成功完成时，程序会自动触发该 fn 函数，参数是future。</li></ul><p>使用线程池来执行线程任务的步骤如下：</p><ol><li>调用 ThreadPoolExecutor 类的构造器创建一个线程池。</li><li>定义一个普通函数作为线程任务。</li><li>调用 ThreadPoolExecutor 对象的 submit() 方法来提交线程任务。</li><li>当不想提交任何任务时，调用 ThreadPoolExecutor 对象的 shutdown() 方法来关闭线程池。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 定义一个准备作为线程任务的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):</span><br>    my_sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>):<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name + <span class="hljs-string">&#x27;  &#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        my_sum += i<br>    <span class="hljs-keyword">return</span> my_sum<br><span class="hljs-comment"># 创建一个包含2条线程的线程池</span><br>pool = ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>)<br><span class="hljs-comment"># 向线程池提交一个task, 50会作为action()函数的参数</span><br>future1 = pool.submit(action, <span class="hljs-number">50</span>)<br><span class="hljs-comment"># 向线程池再提交一个task, 100会作为action()函数的参数</span><br>future2 = pool.submit(action, <span class="hljs-number">100</span>)<br><span class="hljs-comment"># 判断future1代表的任务是否结束</span><br><span class="hljs-built_in">print</span>(future1.done())<br>time.sleep(<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 判断future2代表的任务是否结束</span><br><span class="hljs-built_in">print</span>(future2.done())<br><span class="hljs-comment"># 查看future1代表的任务返回的结果</span><br><span class="hljs-built_in">print</span>(future1.result())<br><span class="hljs-comment"># 查看future2代表的任务返回的结果</span><br><span class="hljs-built_in">print</span>(future2.result())<br><span class="hljs-comment"># 关闭线程池</span><br>pool.shutdown()<br></code></pre></td></tr></table></figure><p>下列程序使用 Executor 的 map() 方法来启动线程，并收集线程任务的返回值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment"># 定义一个准备作为线程任务的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):</span><br>    my_sum = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>):<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name + <span class="hljs-string">&#x27;  &#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        my_sum += i<br>    <span class="hljs-keyword">return</span> my_sum<br><span class="hljs-comment"># 创建一个包含2条线程的线程池</span><br><span class="hljs-comment"># 线程池支持上下文管理协议，用with可以避免忘记写shutdown</span><br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">2</span>) <span class="hljs-keyword">as</span> pool:<br>    <span class="hljs-comment"># 使用线程执行map计算</span><br>    <span class="hljs-comment"># 后面元组有3个元素，因此程序启动3次线程来执行action函数</span><br>    results = pool.<span class="hljs-built_in">map</span>(action, (<span class="hljs-number">50</span>, <span class="hljs-number">100</span>, <span class="hljs-number">150</span>))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--------------&#x27;</span>)<br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:<br>        <span class="hljs-built_in">print</span>(r)<br></code></pre></td></tr></table></figure><p>上面程序使用 map() 方法来启动 3 个线程，但是线程池最多两个线程，所以在输出中你可以看到，刚开始是两个线程都在输出，到后面线程1先被执行完毕，接了<code>action(150)</code>的活，于是后面输出的都是线程1了。</p><p>通过上面程序可以看出，使用 map() 方法来启动线程，并收集线程的执行结果，不仅具有代码简单的优点，而且虽然程序会以并发方式来执行 action() 函数，但最后收集的 action() 函数的执行结果，依然与传入参数的结果保持一致。也就是说，上面 results 的第一个元素是 action(50) 的结果，第二个元素是 action(100) 的结果，第三个元素是 action(150) 的结果。</p><h2 id="信号量-semaphore"><a href="#信号量-semaphore" class="headerlink" title="信号量 semaphore"></a>信号量 semaphore</h2><p>信号量和线程池非常相似。信号量也可以用来控制并发的线程数，它初始化时设定一个计数器，每次<code>acquire()</code>让计数器-1，<code>release()</code>让计数器+1，这个计数器不会小于零，当它为零时，下一个<code>acquire()</code>要等待另一个线程的<code>release()</code>，从而控制实际工作的线程数量。</p><p>可以把它理解为多把相同的锁Locks。</p><p>信号量与线程池的区别：</p><ul><li>信号量需要手动创建线程，线程池自动创建线程。</li><li>信号量需要手动通过<code>acquire()</code>和<code>release()</code>来限流，线程池只用指定任务，其他自动。</li><li>信号量你创建了多少个线程就有多少个线程，没有获得(acquire)信号(semaphore)的线程等待，可能造成内存开销增大。</li></ul><p>信号量类的函数介绍</p><ul><li><code>acquire(blocking=True, timeout=None)</code>：返回是否成功调用，超时返回false</li><li><code>release()</code>：释放一个信号量</li><li><code>Semaphore(value=1)</code>：构造函数，只有一个参数。</li></ul><p>下列代码介绍了信号量的使用以及与线程池的使用方法不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> concurrent.futures <span class="hljs-keyword">import</span> ThreadPoolExecutor<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-comment">## 线程池使用</span><br><span class="hljs-comment"># 定义一个准备作为线程任务的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action1</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>):<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name + <span class="hljs-string">&#x27;  &#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        time.sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-comment"># 创建一个包含3条线程的线程池</span><br>beg = time.perf_counter()<br>futures = []<br><span class="hljs-keyword">with</span> ThreadPoolExecutor(max_workers=<span class="hljs-number">3</span>) <span class="hljs-keyword">as</span> pool:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>        futures.append(pool.submit(action1,<span class="hljs-number">5</span>))        <br><span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> futures:<br>    future.result()<br>end = time.perf_counter()<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;time use: &quot;</span>,end-beg)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------&quot;</span>)<br><br><span class="hljs-comment">## 信号量使用</span><br>sem = threading.Semaphore(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 定义一个有三个信号的信号量</span><br><span class="hljs-comment"># 定义一个准备作为线程任务的函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">action2</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):</span><br>    sem.acquire()  <span class="hljs-comment"># 需要手动获得信号</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">max</span>):<br>        <span class="hljs-built_in">print</span>(threading.current_thread().name + <span class="hljs-string">&#x27;  &#x27;</span> + <span class="hljs-built_in">str</span>(i))<br>        time.sleep(<span class="hljs-number">0.1</span>)<br>    sem.release()  <span class="hljs-comment"># 需要手动释放信号</span><br><br>beg = time.perf_counter()<br><span class="hljs-comment"># 创建6个线程，都开始</span><br>threads = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    t = threading.Thread(target=action2,args=(<span class="hljs-number">5</span>,))<br>    threads.append(t)<br>    t.start()<br><span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:<br>    t.join()<br>end = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;time use: &quot;</span>,end-beg)<br></code></pre></td></tr></table></figure><p>结果统计了时间，发现在线程池中线程数量和信号量相同时，耗时也几乎相同。</p><h2 id="事件-event"><a href="#事件-event" class="headerlink" title="事件 event"></a>事件 event</h2><p>假如其他线程知道另一个线程的某种状态才能进行下一步操作，就可以使用事件event来处理。这几乎是最简单的一个机制。</p><p>函数介绍：</p><ul><li><code>is_set()</code>：当事件发生时（内部标志为True时）返回True</li><li><code>set()</code>：通告事件发生（将内部标志设为True）</li><li><code>clear()</code>：重置为未发生（将内部标志设为False）</li><li><code>wait(timeout=None)</code>：阻塞线程直到事件发生，超时返回False。</li></ul><p>下列代码通过考试的例子说明事件的使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br>ExamBegEvent = threading.Event()<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">student</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;学生[&#123;&#125;]等待考试开始&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>))<br>    ExamBegEvent.wait()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;学生[&#123;&#125;]开始考试&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">teacher</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;老师：开始考试！！&quot;</span>)<br>    ExamBegEvent.<span class="hljs-built_in">set</span>()<br>    <br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    threading.Thread(target=student, args=(i,)).start()<br>time.sleep(<span class="hljs-number">3</span>)<br>threading.Thread(target=teacher).start()<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191213.png" alt="9"></p><h2 id="条件变量-Condition"><a href="#条件变量-Condition" class="headerlink" title="条件变量 Condition"></a>条件变量 Condition</h2><p>这玩意我看了各种博主的各种教程，发现都看不懂，于是钻研了下官方文档，也是一知半解。</p><p>下面介绍我理解的某种条件下使用条件变量的方法。</p><p>Condition和某种锁相关联，但是他可以自动创建锁，服从上下文管理协议，用with方便，</p><blockquote><p><code>acquire()</code>和<code>release()</code>用来请求底层锁，像我这种不懂的就不要用了</p></blockquote><ul><li><code>wait(timeout=None)</code>：等待直到被通知(notify)，超时返回False。</li><li><code>wait_for(predicate, timeout=None)</code>：等待直到条件为真。predicate是一个可调用对象且返回值是布尔类型。这个方法会重复调用<code>wait()</code>直到满足判断。超时返回False</li><li><code>notify(n=1)</code>：唤醒处于wait状态（等待这个条件）的n个线程</li><li><code>notify_all()</code>：唤醒处于wait状态（等待这个条件）的所有线程</li></ul><p>使用条件变量的典型情况是将锁用于同步某些共享状态的权限，那些对某些状态的特定改变感兴趣的线程，它们应该重复调用<code>wait()</code>，直到看到所期望的改变发生；而对于修改某个状态的线程，修改完后调用<code>notify()</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 消费一个东西</span><br><span class="hljs-keyword">with</span> cv:<br><span class="hljs-keyword">while</span> <span class="hljs-keyword">not</span> an_item_is_availabe():<br>        cv.wait()<br>    get_an_available_item()<br>    <br><span class="hljs-comment"># 消费一个东西的另一种写法</span><br><span class="hljs-keyword">with</span> cv:<br>    cv.wait_for(an_item_available)<br>    get_an_available_item()<br>    <br><span class="hljs-comment"># 生产一个东西</span><br><span class="hljs-keyword">with</span> cv:<br>    make_an_item_available()<br>    cv.notify()<br></code></pre></td></tr></table></figure><h2 id="定时器-Timer"><a href="#定时器-Timer" class="headerlink" title="定时器 Timer"></a>定时器 Timer</h2><p>是Thread的子类，像一个自定义线程一样。</p><p>定时器的函数介绍：</p><ul><li><p><code>Timer(interval, function, args, kwargs)</code>：指定延时的事件和要执行的函数和参数。</p></li><li><p><code> Timer.start()</code>：开启定时器，经过一定事件后执行。</p></li><li><p><code>Timer.cancel()</code>：取消定时器。</p></li></ul><h2 id="栅栏-Barrier"><a href="#栅栏-Barrier" class="headerlink" title="栅栏 Barrier"></a>栅栏 Barrier</h2><p>与其叫栅栏，不如叫开车对象。这个类的功能是等人齐就发车。并且一趟车走之后自动开启下一趟车，</p><p>翻车条件：超时、强行abort。</p><p>抛出错误条件：wait的时候翻车，wait的时候发新车。</p><p>下面介绍Barrier的函数和属性： </p><ul><li><code>Barrier(parties, action=None, timeout=None)</code>：parties是数量，当阻塞的线程到达这个数量是就放行（当乘客到达这个数字时就发车）。action是随机抽取一个幸运线程，发车时让这个线程先执行action函数再干自己的事。超时后翻车。</li><li><code>wait(timeout=None)</code>：线程上车，等开车，这里的timeout会<strong>覆盖</strong>Barrier的timeout，超时会强行发车。返回一个范围在0到parties-1的整数，每个线程都不同，可用于从所有线程中选择唯一的一个线程执行一些特别的工作。如果车翻了抛出BrokenBarrierError错误。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">i = barrier.wait()<br><span class="hljs-keyword">if</span> i==<span class="hljs-number">0</span>:  <br><span class="hljs-comment"># do something</span><br></code></pre></td></tr></table></figure><ul><li><code>reset()</code>：重置Barrier的状态，即再发一辆新车。假如有人上了旧车，那些人会抛出BrokenBarrierError错误</li><li><code>abort()</code>：一般用来防止死锁，强行翻车。通常给Barrier设置超时时间而不用这个。</li><li><code>parties</code>：发车需要的人数量。</li><li><code>n_waiting</code>：正在车上的人的数量。</li><li><code>broken</code>：布尔值，栅栏有没有烂，即车有没有翻。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread, current_thread, Barrier, BrokenBarrierError<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lucky</span>():</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&#123;&#125;]成为了司机！！&quot;</span>.<span class="hljs-built_in">format</span>(current_thread().name))<br><br>car = Barrier(<span class="hljs-number">3</span>, action=lucky)  <span class="hljs-comment"># 三轮车</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">people</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&#123;&#125;]要上车！！&quot;</span>.<span class="hljs-built_in">format</span>(current_thread().name))<br>        car.wait()<br>    <span class="hljs-keyword">except</span> BrokenBarrierError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;[&#123;&#125;]要上的车翻啦~QWQ&quot;</span>.<span class="hljs-built_in">format</span>(current_thread().name))<br><br><span class="hljs-comment"># 四人准备上车</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>    t = Thread(target=people)<br>    t.start()<br>    <br>time.sleep(<span class="hljs-number">0.5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;现在有&#123;&#125;人在等车&quot;</span>.<span class="hljs-built_in">format</span>(car.n_waiting))<br><br>car.reset() <span class="hljs-comment"># 再开一辆</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;现在这辆车不要啦~&quot;</span>)<br><br>t1 = Thread(target=people)<br>t2 = Thread(target=people)<br>t1.start()<br>t2.start()<br>time.sleep(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;现在有&#123;&#125;人在等车&quot;</span>.<span class="hljs-built_in">format</span>(car.n_waiting))<br>car.abort()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;翻车啦！&quot;</span>)<br></code></pre></td></tr></table></figure><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301191223.png" alt="10"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="http://c.biancheng.net/view/2617.html">http://c.biancheng.net/view/2617.html</a></p><p><a href="https://blog.csdn.net/luohuacanyue/article/details/14648185">https://blog.csdn.net/luohuacanyue/article/details/14648185</a></p><p><a href="http://c.biancheng.net/view/2627.html">http://c.biancheng.net/view/2627.html</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Video Captioning相关论文调查</title>
    <link href="/2021/03/01/Video-Caption-Related-Papers/"/>
    <url>/2021/03/01/Video-Caption-Related-Papers/</url>
    
    <content type="html"><![CDATA[<h1 id="Video-Captioning相关论文调查"><a href="#Video-Captioning相关论文调查" class="headerlink" title="Video Captioning相关论文调查"></a>Video Captioning相关论文调查</h1><p>不是一个综述，不会全面解析论文，只是一个调查笔记，而且本人水平不高，部分地方可能有错误。</p><p>对目前基于深度学习的Video Captioning(视频描述)的论文进行调查，统计现在得到的最好结果。</p><h2 id="S2VT"><a href="#S2VT" class="headerlink" title="S2VT"></a>S2VT</h2><p><em>S. Venugopalan, M. Rohrbach, J. Donahue, R. J. Mooney, T. Darrell, and K. Saenko. Sequence to sequence - video to text. In ICCV, 2015</em></p><p><strong>代码实现</strong>：</p><ul><li>官方caffe：<a href="https://github.com/vsubhashini/caffe/tree/recurrent/examples/s2vt">https://github.com/vsubhashini/caffe/tree/recurrent/examples/s2vt</a></li><li>复现pytorch：<a href="https://github.com/xiadingZ/video-caption.pytorch">xiadingZ/video-caption.pytorch: pytorch implementation of video captioning (github.com)</a></li><li>我的复现（pytorch）（暂未完成，最新可看readme）：<a href="https://github.com/Kamino666/S2VT-video-caption">Kamino666/S2VT-video-caption: the recurrence of paper “Sequence to Sequence – Video to Text” (github.com)</a></li></ul><p><strong>论文简介</strong>：</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301112335.png" alt="image-20210301112335348" style="zoom:50%;" /><p>大概结构如图，对于视频图像，使用预训练的CNN网络，对视频的每一帧进行特征的提取，每个视频会得到一个[len, feat_dim]的特征，其中每个视频的len不相同。视频的图像输入，可以是RGB图像也可以是光流图。论文中RGB用VGG16，光流图用AlexNet提取feature。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301112655.png" alt="红色为图像层，绿色为文字层"></p><p>训练时，之前由CNN提取的不定长的feature，在编码阶段逐步送进图像层，在图像输入结束后，给文字层提供<code>&lt;BOS&gt;</code>标志开始预测文字，预测到文字层输出<code>&lt;EOS&gt;</code>结束。这样实现了输入和输出都能不定长度。文字层的输入由图像层的输出结合文字输入得到（这里的结合是在hid之前那个维度上的拼接）。</p><p>由于要保持格式不变，在图像输入结束之前，给文字层提供的文字数据是<code>&lt;pad&gt;</code>，在图像输入之后，给图像层提供的图像数据是<code>&lt;pad&gt;</code>。<code>&lt;pad&gt;</code>在实现中简单填充为0.</p><p>注意实现的时候这两层的输入大小不同，得分成两个CNN。</p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 29.8%，M-VAD数据集 METEOR 6.7%，MPII-MD数据集 METEOR 7.1%。</p><h2 id="Multimodal-Memory-Modelling"><a href="#Multimodal-Memory-Modelling" class="headerlink" title="Multimodal Memory Modelling"></a>Multimodal Memory Modelling</h2><p><em>Wang J, Wang W, Huang Y, et al. M3: Multimodal memory modelling for video captioning. CVPR, IEEE 2018</em></p><p><strong>论文简介</strong>：</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301113305.png" alt="image-20210301090931120" style="zoom: 67%;" /><p>对记忆建模（Memory Modeling），主要处理长视频，比较复杂，没深入研究。</p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 33.3%，MSR-VTT数据集 METEOR 26.58%。</p><h2 id="MRS（Multi-Representation-Switching）"><a href="#MRS（Multi-Representation-Switching）" class="headerlink" title="MRS（Multi-Representation Switching）"></a>MRS（Multi-Representation Switching）</h2><p><em>Heechan Kim, Soowon Lee. A Video Captioning Method Based on Multi-Representation Switching for Sustainable Computing. Sustainability 2021</em></p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301115135.png" alt="image-20210301115135156"></p><p>比较新的一篇论文，在Sustainability上发的，所以注重可持续计算，网络不大。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301120022.png" alt="image-20210301120022647"></p><p>作者的思想就是认为在Video Caption生成的句子中，有的单词是要依靠画面来生成的，而有的单词只是语法需要，比如图中“a baby is dancing on a chair”，只有标了颜色的那几个单词是要从画面中提取的，其余都是语法上的要求。</p><p>所以作者分别弄了行为特征模块和文字特征模块，通过一个switcher来学习使用哪个模块。</p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 34.0%。</p><h2 id="RecNet"><a href="#RecNet" class="headerlink" title="RecNet"></a>RecNet</h2><p><em>Bairui Wang, Lin Ma, Wei Zhang, Wei Liu. Reconstruction Network for Video Captioning. arxiv 1803.11438</em></p><p><a href="https://zhuanlan.zhihu.com/p/79810631">Reconstruction Network for Video Captioning - 知乎 (zhihu.com)</a></p><p><strong>论文简介</strong></p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301120712.png" alt="image-20210301120712622"></p><p>腾讯AI实验室的一篇论文，在解码器后面新增了一个Reconstructor。Encoder和Decoder不是重点，可以用注意力机制的模型，也可以用S2VT。</p><p>重点是Reconstructor，Reconstructor是搭建在解码器之上的，旨在根据解码器的隐状态h，恢复原视频信息。但是考虑到原视频帧的多样性以及较高的维度，这种方案较为棘手。因此重建为由编码器得到的视觉特征也是个很好的选择。Reconstructor可以加强视觉序列和caption之间的关系，有望于改善video caption的质量。在具体实现上，Reconstructor是一个LSTM，文中提供两种结构的Reconstructor，分别是侧重于原始视频的全局结构和局部结构。</p><p>（这一部分还待更仔细看一看论文，预计会专门写一篇感想。）</p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 34.1%。</p><h2 id="OA-BTG"><a href="#OA-BTG" class="headerlink" title="OA-BTG"></a>OA-BTG</h2><p><em>Junchao Zhang and Yuxin Peng, Object-aware Aggregation with Bidirectional Temporal Graph for Video Captioning, 2019 CVPR.</em> </p><p><a href="https://zhuanlan.zhihu.com/p/73935242">使用双向时空图做视频描述(video captioning) - 知乎 (zhihu.com)</a></p><p><strong>论文简介</strong>：</p><p>太复杂了，不适用于我目前的研究。但是这篇论文是目前找到的效果最好的。(但是有点作弊的是它输入数据还手动分隔了对象的区域)</p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 36.2%， MSR-VTT数据集 METEOR 28.2%。</p><h2 id="multirate-GRU"><a href="#multirate-GRU" class="headerlink" title="multirate GRU"></a>multirate GRU</h2><p><em>Linchao Zhu, Zhongwen Xu, Yi Yang. Bidirectional Multirate Reconstruction for Temporal Modeling in Videos. 2016, arxiv 1611.09053v1.</em></p><p><strong>论文简介</strong>：</p><p>不是专门弄video caption的，论文中提到的很少。论文主要是用到了多速率GRU的技术，即让GRU有的一个一个读，有的隔一个读，有的隔两个，这样形成不同的速率。没有仔细读这篇论文，仅记录下效果。</p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 33.4%</p><h2 id="GRU-EVE"><a href="#GRU-EVE" class="headerlink" title="GRU-EVE"></a>GRU-EVE</h2><p><em>Nayyer Aafaq, Naveed Akhtar et. Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning. 2019, arxiv 1902.10322v2.</em></p><p><a href="https://blog.csdn.net/chr1991/article/details/103806439">论文介绍–Spatio-Temporal Dynamics and Semantic Attribute Enriched Visual Encoding for Video Captioning_信道者-CSDN博客 </a></p><p><strong>论文简介</strong>：</p><p>挺复杂的，结合了2D-CNN 3D-CNN和对象识别三个数据来源，还用了一个什么傅里叶变换.第一就是用层级的短时傅里叶变换对卷积网络提取出来的特征进行浓缩，把时间信息融入其中；第二就是用物体检测模型从视频中提取高层的语义信息，丰富编码器提炼的视频表示。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301130437.png" alt="image-20210301090845060"></p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 35.0%， MSR-VTT数据集 METEOR 28.4%</p><h2 id="SibNet"><a href="#SibNet" class="headerlink" title="SibNet"></a>SibNet</h2><p><em>Sheng Liu, Zhou Ren, Junsong Yuan. SibNet: Sibling Convolutional Encoder for Video Captioning. <a href="https://doi.org/10.1145/3240508.3240667">https://doi.org/10.1145/3240508.3240667</a></em></p><p><strong>论文简介</strong>：</p><p>重点在于encode videos。编码分成两部分，一部分用自编码器，另一部分用一种视觉语义互相组合embed的编码（目前理解也是非监督学习）。然后这两个编码再解码生成caption，这三部分都有train_loss。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210301131059.png" alt="image-20210301090803104"></p><p><strong>实验结果</strong>：</p><p>MSVD数据集 METEOR 34.8%， MSR-VTT数据集 METEOR 27.5%</p><h1 id="MSVD数据集汇总"><a href="#MSVD数据集汇总" class="headerlink" title="MSVD数据集汇总"></a>MSVD数据集汇总</h1><table><thead><tr><th>模型名字</th><th>METEOR</th></tr></thead><tbody><tr><td>S2VT</td><td>29.8</td></tr><tr><td>M^3^-C3D+InceptionV3</td><td>33.3</td></tr><tr><td>MRS-ew+</td><td>34.0</td></tr><tr><td>RecNet<del>local</del>(SA-LSTM)</td><td>34.1</td></tr><tr><td>OA-BTG</td><td>36.2</td></tr><tr><td>mGRU</td><td>34.5</td></tr><tr><td>GRU-EVE</td><td>35.0</td></tr><tr><td>SibNet</td><td>34.8</td></tr></tbody></table><h1 id="MSR-VTT数据集汇总"><a href="#MSR-VTT数据集汇总" class="headerlink" title="MSR-VTT数据集汇总"></a>MSR-VTT数据集汇总</h1><table><thead><tr><th>模型名字</th><th>METEOR</th></tr></thead><tbody><tr><td>M^3^</td><td>26.6</td></tr><tr><td>OA-BTG</td><td>28.2</td></tr><tr><td>RecNet</td><td>26.6</td></tr><tr><td>GRU-EVE</td><td>28.4</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux常用打包、压缩、解压指令</title>
    <link href="/2021/02/23/Linux%E5%B8%B8%E7%94%A8%E6%89%93%E5%8C%85%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E6%8C%87%E4%BB%A4/"/>
    <url>/2021/02/23/Linux%E5%B8%B8%E7%94%A8%E6%89%93%E5%8C%85%E3%80%81%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux常用打包、压缩、解压指令"><a href="#Linux常用打包、压缩、解压指令" class="headerlink" title="Linux常用打包、压缩、解压指令"></a>Linux常用打包、压缩、解压指令</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>打包</strong>是指将一大堆文件或目录打包为一个文件。</p><p><strong>压缩</strong>是将一个大文件通过某些压缩算法压缩为一个更小的文件。</p><p>Linux很多压缩程序只能针对一个文件进行压缩，要压缩很多文件时，要<strong>先打包再压缩。</strong></p><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><p>tar命令可以为Linux的文件和目录创建档案。tar可以进行打包、压缩、解压三种操作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># tar命令基本格式</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 必须包含-f 以及解包或者打包或者查看的指令</span></span><br>tar [指令] [参数（若需要）] <br><span class="hljs-meta">   #</span><span class="bash"><span class="hljs-comment"># 下面这两行命令是等价的</span></span><br>tar -c -v -f new.tar /home/tmp/file/<br>tar -cvf new.tar /home/tmp/file/<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 常用参数</span></span> <br>-c  # create 建立新文件（打包或者压缩）<br>-x  # extract 解压，解包<br>-t  # list 列出备份文件内容<br>-r  # renew 添加文件到已经压缩的文件<br>-f  # file 作为最后一个参数 ，表示新建的文件名，可以随意指定后缀名，但最好用指定的名字。Linux不根据后缀名识别文件类型。<br><br>-v  # verbose 打包或者解压时显示详细信息<br>-C  # 大写的C 解压、解包到某特定目录<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 压缩参数</span></span><br>-z  # 用gzip命令处理  .tar.gz<br>-j  # 用bzip2命令处理  .tar.bz2<br><br>tar -cvf new.tar ./file/  # 将./file/目录下所有文件打包为new.tar，并保存在当前目录，过程显示详细信息<br>tar -cvf new.tar ./file1/ ./file2/  # 可以一次包含多个目录<br>tar -tvf new.tar  # 不解包的情况下查看包内文件信息<br>tar -xvf new.tar -C ./file3/ # 解压new,tar到另一个目录<br>tar -rvf new.tar ./file4/  # 向new.tar中加入新的目录<br></code></pre></td></tr></table></figure><h2 id="其他压缩命令"><a href="#其他压缩命令" class="headerlink" title="其他压缩命令"></a>其他压缩命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## zip .zip</span></span><br>zip new.zip ./file  # 压缩<br>-m  # 压缩后删除源文件<br>-q  # 安静模式<br>-o  # 将文件最新变动时间更新<br>-r  # 压缩目录<br>-S  # 大写S 包含系统和隐藏文件<br>-[1-9]  # 压缩效率 1表示最快<br>unzip new.zip  # 解压<br>-n  # 解压时不覆盖原有文件<br>-o  # 解压后覆盖原有文件<br>-q  # 安静模式<br>-P [密码]  # 解压密码<br>-d [目录]  # 选择解压目录<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex Math语法</title>
    <link href="/2021/02/23/LaTex%20Math%E8%AF%AD%E6%B3%95/"/>
    <url>/2021/02/23/LaTex%20Math%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="LaTeX-Math语法"><a href="#LaTeX-Math语法" class="headerlink" title="LaTeX Math语法"></a>LaTeX Math语法</h1><p>一个充满干货的速查语法文章。</p><h2 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h2><p>使用<code>$字母语法$</code>来使用，首字母大小写决定了希腊字母的大小写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">$\Gamma$ $\gamma$<br></code></pre></td></tr></table></figure><p>$\Gamma$ $\gamma$</p><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td><code>A</code></td><td>α</td><td><code>\alhpa</code></td></tr><tr><td>B</td><td><code>B</code></td><td>β</td><td><code>\beta</code></td></tr><tr><td>Γ</td><td><code>\Gamma</code></td><td>γ</td><td><code>\gamma</code></td></tr><tr><td>Δ</td><td><code>\Delta</code></td><td>δ</td><td><code>\delta</code></td></tr><tr><td>E</td><td><code>E</code></td><td>ϵ</td><td><code>\epsilon</code></td></tr><tr><td>Z</td><td><code>Z</code></td><td>ζ</td><td><code>\zeta</code></td></tr><tr><td>H</td><td><code>H</code></td><td>η</td><td><code>\eta</code></td></tr><tr><td>Θ</td><td><code>\Theta</code></td><td>θ</td><td><code>\theta</code></td></tr><tr><td>I</td><td><code>I</code></td><td>ι</td><td><code>\iota</code></td></tr><tr><td>K</td><td><code>K</code></td><td>κ</td><td><code>\kappa</code></td></tr><tr><td>Λ</td><td><code>\Lambda</code></td><td>λ</td><td><code>\lambda</code></td></tr><tr><td>M</td><td><code>M</code></td><td>μ</td><td><code>\mu</code></td></tr><tr><td>N</td><td><code>N</code></td><td>ν</td><td><code>\nu</code></td></tr><tr><td>Ξ</td><td><code>\Xi</code></td><td>ξ</td><td><code>\xi</code></td></tr><tr><td>O</td><td><code>O</code></td><td>ο</td><td><code>\omicron</code></td></tr><tr><td>Π</td><td><code>\Pi</code></td><td>π</td><td><code>\pi</code></td></tr><tr><td>P</td><td><code>P</code></td><td>ρ</td><td><code>\rho</code></td></tr><tr><td>Σ</td><td><code>\Sigma</code></td><td>σ</td><td><code>\sigma</code></td></tr><tr><td>T</td><td><code>T</code></td><td>τ</td><td><code>\tau</code></td></tr><tr><td>Υ</td><td><code>\Upsilon</code></td><td>υ</td><td><code>\upsilon</code></td></tr><tr><td>Φ</td><td><code>\Phi</code></td><td>ϕ</td><td><code>\phi</code></td></tr><tr><td>X</td><td><code>X</code></td><td>χ</td><td><code>\chi</code></td></tr><tr><td>Ψ</td><td><code>\Psi</code></td><td>ψ</td><td><code>\psi</code></td></tr><tr><td>Ω</td><td><code>\v</code></td><td>ω</td><td><code>\omega</code></td></tr></tbody></table><h2 id="三角函数、对数、指数"><a href="#三角函数、对数、指数" class="headerlink" title="三角函数、对数、指数"></a>三角函数、对数、指数</h2><p>使用<code>$符号语法$</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$\tan$、$\sin$、$\cos$、$\lg$、$\arcsin$、$\arctan$、$\min$、$\max$、$\exp$、$\log$<br>$\log_n(2)$ $\circ$<br></code></pre></td></tr></table></figure><p>$\tan$、$\sin$、$\cos$、$\lg$、$\arcsin$、$\arctan$、$\min$、$\max$、$\exp$、$\log$</p><p>$\log_2(2)$ $30^\circ$</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">$+$、$-$、$=$、$&gt;$、$&lt;$、$\times$、$\div$、$\equiv$、$\leq$、$\geq$、$\neq$ $!$<br>$\pm$ $\mp$ $\cdot$ $\ast$ || $\frac&#123;分子&#125;&#123;分母&#125;$  $&#123;分子&#125; \voer &#123;分母&#125;$<br>$\sqrt&#123;&#125;$ $\sqrt[n]&#123;&#125;$<br></code></pre></td></tr></table></figure><p>$+$、$-$、$=$、$&gt;$、$&lt;$、$\times$、$\div$、$\equiv$、$\leq$、$\geq$、$\neq$  $!$</p><p>$\pm$ $\mp$ $\cdot$ $\ast$ $|x+y|$  $\frac{分子}{分母}$  ${x+y} \over {y+z}$ </p><p>$\sqrt[]{x+y}$ $\sqrt[n]{x+y}$</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">$\cup$、$\cap$、$\in$、$\notin$、$\ni$、$\subset$、$\subseteq$、$\supset$、$\supseteq$、$\infty$<br></code></pre></td></tr></table></figure><p>$\cup$、$\cap$、$\in$、$\notin$、$\ni$、$\subset$、$\subseteq$、$\supset$、$\supseteq$、$\infty$</p><h2 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex">$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$<br>$ [] $ $ \&#123;\&#125; $ $\left(x\right)$<br>$&#123;上位公式 \choose 下位公式&#125;$<br>$&#123;上位公式 \atop 下位公式&#125;$<br></code></pre></td></tr></table></figure><p>$（）\big(\big) \Big(\Big) \bigg(\bigg) \Bigg(\Bigg)$</p><p>$ [] $ $ {} $ $\left(x\right)$ 这个是自动适应符号</p><p>${上位公式 \choose 下位公式}$</p><p>${上位公式 \atop 下位公式}$</p><h2 id="上标下标"><a href="#上标下标" class="headerlink" title="上标下标"></a>上标下标</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs latex">^ _ &#123;&#125;用这个来组合<br></code></pre></td></tr></table></figure><p>$x^4$ $x_1$ ${16}<em>{8}O{2+}</em>{2}$</p><h2 id="内联输出与块状输出"><a href="#内联输出与块状输出" class="headerlink" title="内联输出与块状输出"></a>内联输出与块状输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs latex">$ $<br>$$ $$<br></code></pre></td></tr></table></figure><p>这是一个公式$x^y$</p><p>这是一个公式$$x^y$$</p><h2 id="高级运算"><a href="#高级运算" class="headerlink" title="高级运算"></a>高级运算</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs latex">$\overline&#123;算式&#125;$ <br>$\lim$ $\lim\limits_&#123;x \to y&#125;$<br>$\sum$ $\sum_&#123;n=1&#125;^\infty k$<br></code></pre></td></tr></table></figure><p>$\overline{xyz}$ $$\lim\limits_{x \to \infty} \exp(-x) = 0$$ </p><p>$\sum_{n=1}^\infty k$</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs latex">$$<br>  \begin&#123;matrix&#125;<br>   1 &amp; 2 &amp; 3 \\<br>   4 &amp; 5 &amp; 6 \\<br>   7 &amp; 8 &amp; 9<br>  \end&#123;matrix&#125; <br>$$<br></code></pre></td></tr></table></figure><p>$$<br>\begin{matrix}<br>   1 &amp; 2 &amp; 3 \<br>   4 &amp; 5 &amp; 6 \<br>   7 &amp; 8 &amp; 9<br>  \end{matrix}<br>$$</p><h2 id="分段函数"><a href="#分段函数" class="headerlink" title="分段函数"></a>分段函数</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs latex">$$<br>X(m,n)=<br>\begin&#123;cases&#125;<br>x(n),\\<br>x(n-1)\\<br>x(n-1)<br>\end&#123;cases&#125;<br>$$<br></code></pre></td></tr></table></figure><p>$$<br>X(m,n)=<br>\begin{cases}<br>x(n),\<br>x(n-1)\<br>x(n-1)<br>\end{cases}<br>$$</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTeX</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-Pathlib库基础使用教程</title>
    <link href="/2021/02/23/Python-Pathlib%E5%BA%93%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/23/Python-Pathlib%E5%BA%93%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-Pathlib库基础使用教程"><a href="#Python-Pathlib库基础使用教程" class="headerlink" title="Python-Pathlib库基础使用教程"></a>Python-Pathlib库基础使用教程</h1><p>深度学习处理数据的时候经常使用这个Python库，Pathlib能够很方便地遍历各种样子的文件目录，性能也很好。</p><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">r&#x27;d:\test\tt.txt.bk&#x27;</span>)<br>p.name                          <span class="hljs-comment"># 获取文件名</span><br><span class="hljs-comment"># tt.txt.bk</span><br>p.stem                          <span class="hljs-comment"># 获取文件名除后缀的部分</span><br><span class="hljs-comment"># tt.txt</span><br>p.suffix                        <span class="hljs-comment"># 文件后缀</span><br><span class="hljs-comment"># .bk</span><br>p.suffixs                       <span class="hljs-comment"># 文件的后缀们...</span><br><span class="hljs-comment"># [&#x27;.txt&#x27;, &#x27;.bk&#x27;]</span><br>p.parent                        <span class="hljs-comment"># 相当于dirnanme</span><br><span class="hljs-comment"># WindowsPath(&#x27;d:/test&#x27;)</span><br>p.parents                       <span class="hljs-comment"># 返回一个iterable, 包含所有父目录</span><br><span class="hljs-comment"># &lt;WindowsPath.parents&gt;</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> p.parents:<br>    <span class="hljs-built_in">print</span>(i)<br><span class="hljs-comment"># d:\test</span><br><span class="hljs-comment"># d:\</span><br>a.parts                         <span class="hljs-comment"># 将路径通过分隔符分割成一个元祖</span><br><span class="hljs-comment"># (&#x27;d:\\&#x27;, &#x27;test&#x27;, &#x27;tt.txt.bk&#x27;)</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">r&#x27;d:\test&#x27;</span>)<br>p = Path(p, <span class="hljs-string">&#x27;tt.txt&#x27;</span>)           <span class="hljs-comment"># 字符串拼接</span><br>p.exists()                      <span class="hljs-comment"># 判断文件是否存在</span><br>p.is_file()                     <span class="hljs-comment"># 判断是否是文件</span><br>p.is_dir()                      <span class="hljs-comment"># 判断是否是目录</span><br></code></pre></td></tr></table></figure><h2 id="遍历❤"><a href="#遍历❤" class="headerlink" title="遍历❤"></a>遍历❤</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">r&#x27;d:\test&#x27;</span>)<br><span class="hljs-comment"># WindowsPath(&#x27;d:/test&#x27;)</span><br>p.iterdir()                     <span class="hljs-comment"># 相当于os.listdir 列出子目录/文件</span><br>p.glob(<span class="hljs-string">&#x27;*&#x27;</span>)                     <span class="hljs-comment"># 相当于os.listdir, 列出符合条件的子目录/文件但是可以添加匹配条件</span><br>p.rglob(<span class="hljs-string">&#x27;*&#x27;</span>)                    <span class="hljs-comment"># 相当于os.walk, 递归列出符合条件的子目录/文件也可以添加匹配条件</span><br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">* # 所有<br>? # 单个字符<br>. # 当前目录<br>.. # 上一级目录<br>[0-9] [a-z] [A-Z] # 字面意思<br>[A-Za-z] # 大小写字母 windows路径不分大小写<br>[0-9A-Za-Z] # 数字和字母<br><br>**  # 表示 “此目录以及所有子目录，递归”<br></code></pre></td></tr></table></figure><h2 id="创建文件夹"><a href="#创建文件夹" class="headerlink" title="创建文件夹"></a>创建文件夹</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">r&#x27;d:\test\tt\dd&#x27;</span>)<br>p.mkdir(exist_ok=<span class="hljs-literal">True</span>)          <span class="hljs-comment"># 创建文件目录(前提是tt目录存在, 否则会报错)</span><br><span class="hljs-comment"># 一般我会使用下面这种创建方法</span><br>p.mkdir((exist_ok=<span class="hljs-literal">True</span>, parents=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 递归创建文件目录</span><br></code></pre></td></tr></table></figure><h2 id="文件详细信息-size-createtime…"><a href="#文件详细信息-size-createtime…" class="headerlink" title="文件详细信息(size, createtime…)"></a>文件详细信息(size, createtime…)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">p = Path(<span class="hljs-string">r&#x27;d:\test\tt.txt&#x27;</span>)<br>p.stat()                        <span class="hljs-comment"># 获取详细信息</span><br><span class="hljs-comment"># os.stat_result(st_mode=33206, st_ino=562949953579011, st_dev=3870140380, st_nlink=1, st_uid=0, st_gid=0, st_size=0, st_atime=1525254557, st_mtime=1525254557, st_ctime=1525254557)</span><br>p.stat().st_size                <span class="hljs-comment"># 文件大小</span><br><span class="hljs-comment"># 0</span><br>p.stat().st_ctime               <span class="hljs-comment"># 创建时间</span><br><span class="hljs-comment"># 1525254557.2090347</span><br><span class="hljs-comment"># 其他的信息也可以通过相同方式获取</span><br>p.stat().st_mtime               <span class="hljs-comment"># 修改时间</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>机器学习</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux基础学习笔记(随缘会更新)</title>
    <link href="/2021/02/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E9%9A%8F%E7%BC%98%E4%BC%9A%E6%9B%B4%E6%96%B0)/"/>
    <url>/2021/02/23/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(%E9%9A%8F%E7%BC%98%E4%BC%9A%E6%9B%B4%E6%96%B0)/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux基础学习笔记-随缘会更新"><a href="#Linux基础学习笔记-随缘会更新" class="headerlink" title="Linux基础学习笔记(随缘会更新)"></a>Linux基础学习笔记(随缘会更新)</h1><p>记录一些基本的能用上的命令。之后假如遇到了什么新的命令会在这更新。</p><p>第一次更新：用学校科研平台的时候发现查看资源的几个命令能用上</p><p>第二次更新：更新了一些超常用的命令速查</p><h2 id="超常用命令速查！！"><a href="#超常用命令速查！！" class="headerlink" title="超常用命令速查！！"></a>超常用命令速查！！</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">ls -alh  <span class="hljs-comment"># 人性化显示所有文件</span><br>tar -cvf xxx.tar ./data1/ ./data2/  <span class="hljs-comment"># 打包文件，不压缩！</span><br>tar -czvf xxx.tar.gz ./data1/ ./data2/  <span class="hljs-comment"># 压缩文件</span><br>tar -xvf xxx.tar -C ./data/ <span class="hljs-comment"># 解压xxx.tar</span><br>du -h /data/  <span class="hljs-comment"># 人性化显示文件占用磁盘大小</span><br>df -h  <span class="hljs-comment"># 显示磁盘分区可用空间</span><br>find /var/<span class="hljs-built_in">log</span>/ -<span class="hljs-built_in">type</span> f -<span class="hljs-built_in">print</span> | wc -l  <span class="hljs-comment"># 查看目录下有多少文件</span><br></code></pre></td></tr></table></figure><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="ls-：-list，列出目录"><a href="#ls-：-list，列出目录" class="headerlink" title="ls ： list，列出目录"></a>ls ： list，列出目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls<br>-a  # all 全部的文件，包括隐藏文件<br>-l  # long 详细信息<br>-h  # 配合-l以人性化的方式显示文件大小<br>-i  # 显示inode信息<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 可以组合使用</span></span><br>ls -lha  # 结合三个标签的效果，可以乱序<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># ls及其他命令可能使用的通配符</span></span><br>*  # 任意个数字符<br>?  # 任意一个字符，不能多也不能少<br>[]  # 匹配字符组中任意一个,比如下列<br>[abc]  # 匹配abc中任意一个<br>[a-f]  # 匹配a到f内任意一个<br>[1-9]  # 匹配1到9内任意一个<br></code></pre></td></tr></table></figure><h3 id="cd：-change-dir，改变工作目录"><a href="#cd：-change-dir，改变工作目录" class="headerlink" title="cd： change dir，改变工作目录"></a>cd： change dir，改变工作目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Linux所有目录和文件名大小写敏感</span></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># cd后可能用的特殊路径</span></span><br>cd ~  # 当前用户主目录<br>cd .  # 当前目录<br>cd ..  # 上级目录<br>cd -  # 最近两次工作目录间切换<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 相对路径与绝对路径</span></span><br>cd /home/tmp  # 绝对路径，最前面是~或者/<br>cd file/src  # 相对路径，表示当前目录下的文件<br></code></pre></td></tr></table></figure><h3 id="mkdir-make-dir-创建新目录"><a href="#mkdir-make-dir-创建新目录" class="headerlink" title="mkdir: make dir, 创建新目录"></a>mkdir: make dir, 创建新目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir [目录名字]<br>-p  # 可以递归创建目录<br></code></pre></td></tr></table></figure><h3 id="rmdir：-remove-dir，删除空目录"><a href="#rmdir：-remove-dir，删除空目录" class="headerlink" title="rmdir： remove dir，删除空目录"></a>rmdir： remove dir，删除空目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmdir [目录名字]<br>-P  # 删除指定空目录，假如上一级也是空那也删除<br></code></pre></td></tr></table></figure><h3 id="rm-remove-删除文件或目录"><a href="#rm-remove-删除文件或目录" class="headerlink" title="rm: remove, 删除文件或目录"></a>rm: remove, 删除文件或目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm [文件名]<br>-f  # 强制删除，忽略不存在的文件<br>-r  # 删除目录<br>-i  # 会询问一次<br></code></pre></td></tr></table></figure><h3 id="pwd-print-working-dir，显示目前所在目录"><a href="#pwd-print-working-dir，显示目前所在目录" class="headerlink" title="pwd: print working dir，显示目前所在目录"></a>pwd: print working dir，显示目前所在目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd<br>-P  # 显示出真实路径而非link路径<br></code></pre></td></tr></table></figure><h3 id="cp-copy，复制文件"><a href="#cp-copy，复制文件" class="headerlink" title="cp: copy，复制文件"></a>cp: copy，复制文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp [参数] [来源] [目标]<br>-d  # 若复制的文件是link，则复制link而非文件本身<br>-p  # 复制文件的属性，备份常用<br>-r  # 递归复制，能复制目录<br>-a  # -pdr<br><br>-f  # force，若目标已存在且无法开启，则删除后再试一次<br>-i  # 若目标已存在，会先询问再覆盖<br></code></pre></td></tr></table></figure><h3 id="mv-move，移动文件或修改名称"><a href="#mv-move，移动文件或修改名称" class="headerlink" title="mv: move，移动文件或修改名称"></a>mv: move，移动文件或修改名称</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv [参数] [来源] [目标]<br>-f  # force，若目标已存在且无法开启，则删除后再试一次<br>-i  # 若目标已存在，会先询问再覆盖<br>-u  # 若目标文件已存在，且来源更新，才会覆盖<br>mv file file2  # 重命名操作<br></code></pre></td></tr></table></figure><h3 id="ln-链接"><a href="#ln-链接" class="headerlink" title="ln: 链接"></a>ln: 链接</h3><blockquote><h2 id="硬连接"><a href="#硬连接" class="headerlink" title="硬连接"></a><strong>硬连接</strong></h2><p>硬连接指通过索引节点来进行连接。<strong>在 Linux 的文件系统中，保存在磁盘分区中的文件不管是什么类型都给它分配一个编号</strong>，称为<strong>索引节点号(Inode Index)<strong>。在 Linux 中，多个文件名指向同一索引节点是存在的。比如：A 是 B 的硬链接（A 和 B 都是文件名），则 A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号相同，即一个 inode 节点对应两个不同的文件名，两个文件名指向同一个文件，</strong>A 和 B 对文件系统来说是完全平等的。删除其中任何一个都不会影响另外一个的访问。</strong></p><p>硬连接的作用是允许一个文件拥有多个有效路径名，这样用户就可以建立硬连接到重要文件，以防止“误删”的功能。其原因如上所述，因为对应该目录的索引节点有一个以上的连接。<strong>只删除一个连接并不影响索引节点本身和其它的连接，只有当最后一个连接被删除后，文件的数据块及目录的连接才会被释放。</strong>也就是说，文件真正删除的条件是与之相关的所有硬连接文件均被删除。</p><p><em><strong>不允许给目录创建硬链接</strong></em></p><h2 id="软连接"><a href="#软连接" class="headerlink" title="软连接"></a><strong>软连接</strong></h2><p>另外一种连接称之为<strong>符号连接（Symbolic Link），也叫软连接</strong>。软链接文件有类似于 Windows 的快捷方式。它实际上是一个特殊的文件。在符号连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。比如：A 是 B 的软链接（A 和 B 都是文件名），A 的目录项中的 inode 节点号与 B 的目录项中的 inode 节点号不相同，<strong>A 和 B 指向的是两个不同的 inode，继而指向两块不同的数据块。但是 A 的数据块中存放的只是 B 的路径名（可以根据这个找到 B 的目录项）</strong>。A 和 B 之间是“主从”关系，如果 B 被删除了，A 仍然存在（因为两个是不同的文件），但指向的是一个无效的链接。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223234253.png" alt="1 (1)"></p><p>如图，最左边一栏就是inode，a-hard是硬链接，a-light是软连接。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln [参数] [来源] [目标]<br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 必要参数</span></span><br>-b  # 覆盖以前建立的连接<br>-f  # 强制执行<br>-i  # 存在会询问一次<br>-s  # 软连接<br>-v  # 显示过程<br></code></pre></td></tr></table></figure><h3 id="cat-category，由第一行开始显示文件内容"><a href="#cat-category，由第一行开始显示文件内容" class="headerlink" title="cat: category，由第一行开始显示文件内容"></a>cat: category，由第一行开始显示文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat [参数] [目标]<br>-E  # 将结尾的断行字节用$表示<br>-v  # 列出看不出来的特殊字符<br>-T  # 列出tab键为^|<br>-A  # -vET<br><br>-b  # 列出行号，空白行不计<br>-n  # 列出行号，空白行计<br></code></pre></td></tr></table></figure><h3 id="tac-倒过来的cat，从最后一行开始显示文件内容"><a href="#tac-倒过来的cat，从最后一行开始显示文件内容" class="headerlink" title="tac: 倒过来的cat，从最后一行开始显示文件内容"></a>tac: 倒过来的cat，从最后一行开始显示文件内容</h3><h3 id="nl-显示行号"><a href="#nl-显示行号" class="headerlink" title="nl: 显示行号"></a>nl: 显示行号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">nl [参数] [文件]<br>-b a  # 计空行<br>-b t  # 不计空行 默认<br>-w [数字]  # 行号栏所占位数<br></code></pre></td></tr></table></figure><h3 id="more-一页一页翻动"><a href="#more-一页一页翻动" class="headerlink" title="more: 一页一页翻动"></a>more: 一页一页翻动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">space  # 向下翻一页<br>enter  # 向下一行<br>/[字符]  # 向下搜索字符<br>q  # 离开<br>b  # 回翻页 <br></code></pre></td></tr></table></figure><h3 id="head-tail：-前-后几行"><a href="#head-tail：-前-后几行" class="headerlink" title="head/tail： 前/后几行"></a>head/tail： 前/后几行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">head -n [数字] [目标]<br>tail -n [数字] [目标]<br></code></pre></td></tr></table></figure><h2 id="查看系统相关信息"><a href="#查看系统相关信息" class="headerlink" title="查看系统相关信息"></a>查看系统相关信息</h2><h3 id="CPU使用信息"><a href="#CPU使用信息" class="headerlink" title="CPU使用信息"></a>CPU使用信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top  # 查看使用率等<br></code></pre></td></tr></table></figure><h3 id="GPU使用信息"><a href="#GPU使用信息" class="headerlink" title="GPU使用信息"></a>GPU使用信息</h3><p>跑深度学习模型的时候常用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvidia-smi  # 查看显存、GPU使用率等<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git与GitHub使用教程</title>
    <link href="/2021/02/23/Git%E4%B8%8EGithub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2021/02/23/Git%E4%B8%8EGithub%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="Git与GitHub使用教程"><a href="#Git与GitHub使用教程" class="headerlink" title="Git与GitHub使用教程"></a>Git与GitHub使用教程</h1><p>这篇文章是我的学习笔记，借鉴了各种博主的资料和自己的理解整理而成。</p><p>本文从0开始完整介绍Git和GitHub，所以比较长，请灵活运用大纲和搜索功能。</p><h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="Git是什么？"><a href="#Git是什么？" class="headerlink" title="Git是什么？"></a>Git是什么？</h2><p><a href="https://www.runoob.com/manual/git-guide/">参考</a></p><p>Git是目前世界上最先进的<strong>分布式版本控制系统</strong>。</p><p>版本控制的目录叫做一个<strong>仓库(repository)</strong></p><p>你的本地仓库由 Git 维护的三棵“树”组成。第一个是你的 <strong>工作目录</strong>，它持有实际文件；第二个是 <strong>暂存区（Index）</strong>，它像个缓存区域，临时保存你的改动；最后是 <strong>HEAD</strong>，它指向你最后一次提交的结果。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150705.png"></p><p>使用Git的工作流程如下：</p><p>在本地修改、保存之后，通过 <strong>推送(Push)</strong> 操作来提交到远程仓库。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150713.png"></p><p>与其他版本控制系统一样，Git还提供 <strong>分支(branch)</strong> 功能，该功能允许你从开发仓库的主线上分离出一个版本，然后在不影响主线的情况下继续工作。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150717.png"></p><blockquote><p>版本控制系统：</p><p>小明正在写一篇文章，他想删除一个段落，过了一会后，他突然发现他想要回这个段落，于是他苦逼地再打了一遍。</p><p>小红正在写一篇文章，她想删除一个段落，但是她不确定之后是否想恢复这个段落，所以她拷贝了一份，过了一会儿，她又想更改一个段落，也不确定之后是否会想恢复，于是她又拷贝了一份，他的文件夹里出现了很多类似xxxxx-副本（2）的文件，她苦逼地寻找他想要恢复的那个版本。</p><p>张三正在写一篇文章，他使用了Git来管理版本，Git详细记录了每次更改的日期和更改处以及张三自己为改动写的备注。他很开心地写了一篇神作。后面李四想与张三合作这篇文章，李四也使用Git，Git还记录了每次更改的用户。他们很开心地合作了一篇神作。</p></blockquote><blockquote><p>分布式：</p><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896202780297248">参考资料</a></p><p>下图是集中式系统，中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150726.jpeg"></p><p>下图是分布式系统，首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150727.jpeg"></p></blockquote><h2 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h2><h3 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h3><p>Git是一个跨平台的开源软件。<a href="https://git-scm.com/">官网</a>没有被墙而且速度很快，直接下载安装即可。</p><p>Linux系统可以使用<code>sudo apt-get install git</code>安装</p><p>下载安装后，打开终端或Git Bash，我们接下来要配置Git。</p><p>配置要设置你的身份，身份由用户名和邮箱组成，通过一下命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> git config --global user.name <span class="hljs-string">&quot;你的名字&quot;</span></span><br><span class="hljs-meta">$</span><span class="bash"> git config --global user.email <span class="hljs-string">&quot;你的邮箱&quot;</span></span><br></code></pre></td></tr></table></figure><h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><p>最常用的命令是<code>push</code> <code>commit</code> <code>pull</code> <code>clone</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell">git init  # 初始化一个仓库，在此命令之前要从终端进入你想记录更改的那个工作目标里<br><br>git clone &lt;repo&gt;  # 克隆一个仓库 repo是仓库地址<br>git clone &lt;repo&gt; &lt;path&gt; # 克隆一个仓库 path是本地保存路径<br>git clone https://github.com/sample/hello.git  # 克隆github上一个仓库的写法<br><br>git add &lt;文件名&gt;  # 添加某个文件到仓库缓存区<br>git add *  # 添加所有文件<br><br>git commit -m &quot;代码提交备注信息&quot;  # 提交你的代码附带一段备注，你的改动只提交到了HEAD而不是远程仓库。<br><br>git push origin &lt;分支名字&gt;  # 将本地HEAD提交到远程仓库，这个操作叫做push<br>git push origin master  # 每个仓库有一条主线分支叫做master<br><br>git remote add origin &lt;server&gt;  # 假如你不是通过clone来创建仓库的，那么你需要用这个命令来连接到某个远程服务器<br><br>git log  # 查看修改的日志<br><br>git checkout -b &lt;分支名字&gt;  # 创建一个分支并切换过去，分支也要push才能在远程仓库中被看见<br>git checkout &lt;分支名字&gt;   # 切换分支<br>git branch -d &lt;分支名字&gt;  # 删除分支<br><br>git pull  # 更新你的本地仓库，这个操作叫做pull<br>git merge &lt;分支名字&gt;  # 将其他分支合并到你的分支<br><br>git checkout -- &lt;文件名&gt;  # 将尚未commit的内容放弃退回到上一个版本<br>git reset --hard HEAD^  # 退回到上一个版本 HEAD^^为上上个版本 HEAD~n 为上n个版本<br>git reset --hard &lt;commit id&gt;  # 每一次commit有一个单独的ID，通过此命令到相应版本<br><span class="hljs-meta">#</span><span class="bash"> 这两个命令让你放弃所有尚未push的内容，并获取远程仓库上最新的版本</span><br>git fetch origin<br>git reset --hard origin/master<br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/git/git-basic-operations.html">更多操作</a></p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>GitHub是一个面向开源及私有软件项目的托管平台。也就是远程仓库存放的地方。18年被微软收购，目前微软、谷歌以及很多开源项目的代码都托管在改平台。GitHub是最好的代码托管平台。</p><p>界面大概长这样23333</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150732.webp" alt="个人界面"></p><h2 id="使用之前-1"><a href="#使用之前-1" class="headerlink" title="使用之前"></a>使用之前</h2><p>你得先注册一个GitHub账号。<a href="https://github.com/">官网</a></p><p>然后你要创建一个<strong>SSH Key</strong>，这个秘钥用来保证没有别人来瞎改你的仓库，是你的凭证。</p><p>打开终端（git bash）输入下面代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;你的邮箱&quot;</span><br></code></pre></td></tr></table></figure><p>然后在你的用户主目录(Windows下是C:\users\你的用户名)下找到.ssh目录。</p><p>里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，公钥是<code>.pub</code>，打开它，复制里面的内容。</p><p>打开Github的Account settings，在SSH keys里面粘贴。然后添加Key。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150738.webp"></p><h2 id="创建远程仓库-repo"><a href="#创建远程仓库-repo" class="headerlink" title="创建远程仓库(repo)"></a>创建远程仓库(repo)</h2><p>在你的用户界面下的Repositories点new。</p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223152527.webp"></p><p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20210223150742.png"></p><p>Repository name是你仓库的名字。之后是对仓库的描述以及可见性，现在Github上私有库已经免费了，所以这两个随便选。其他暂时默认，点击创建。</p><p>然后你就有了一个远程仓库！</p><p>此时网页会写的很清楚这个仓库的地址，之后你就可以用命令行来git了！</p><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>GitHub有客户端，搜索下载就行了，然后登陆，这样你就不用手动输入命令了。</p><h2 id="README-md"><a href="#README-md" class="headerlink" title="README.md"></a>README.md</h2><p>别人从网页打开你的仓库会有一个初始化文档，让别人知道你这个仓库是用来干什么的，要如何使用你的代码。这些通常用markdown格式书写，并且命名为README.md放在根目录。这个文件会在网站上自动显示。<a href="https://guides.github.com/features/mastering-markdown/">github官方教程</a></p><p>GitHub支持拓展语法：</p><p><strong>emoji</strong>：<code>:blush:</code>:blush:</p><p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">所有emoji代码</a></p><p><strong>@用户</strong>：<code>@username</code>可以@别的用户</p><p><strong>badge</strong>：项目徽章。<a href="http://www.cocoachina.com/articles/19256">教程</a>   <a href="https://shields.io/">Shield.io</a> </p><p><strong>标准写法</strong>：<a href="https://github.com/RichardLitt/standard-readme">Standard Readme</a></p><h2 id="issues"><a href="#issues" class="headerlink" title="issues"></a>issues</h2><p><a href="https://blog.csdn.net/Wuzihui___/article/details/79952068">教程</a></p><p>GitHub为开发者提供了许多便于开发的功能，其中，issues功能被用来追踪各种想法，增强功能，任务，bug等。</p><p>项目维护者可以通过Issues来组织需要完成的任务，例如增加新特性或者审计一个已经上线的功能。同时，还可以将Issues关联某些pull request，一旦合并了某个pull request，这个issue会被自动关闭。同时，你可以将issues添加到看板，也可以将看板的任务转化为issue。</p><h2 id="commit-log"><a href="#commit-log" class="headerlink" title="commit log"></a>commit log</h2><p>feat: 新功能</p><p>change：需求变更</p><p>fix：缺陷修复</p><p>test：修改测试代码</p><p>docs：文档变更</p><p>style：代码格式调整</p><p>refactor：代码重构</p>]]></content>
    
    
    <categories>
      
      <category>未分类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub</tag>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络爬虫进化史，原来你是这样的爬虫：第2期</title>
    <link href="/2021/02/21/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%9A%E7%AC%AC2%E6%9C%9F/"/>
    <url>/2021/02/21/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%9A%E7%AC%AC2%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫进化史，原来你是这样的爬虫：第2期"><a href="#网络爬虫进化史，原来你是这样的爬虫：第2期" class="headerlink" title="网络爬虫进化史，原来你是这样的爬虫：第2期"></a>网络爬虫进化史，原来你是这样的爬虫：第2期</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一期我们说到万维网被发明之后，马修·格雷（Matthew Gray）找到了从万维网上获取数据的好方法，并写出了历史上第一个爬虫——<em>World Wide Web Wanderer</em>，接下来我们将会进入到万维网的黄金发展时期——1993-1994年，同时也是搜索引擎和爬虫发展最迅速的时期~</p><h2 id="What’s-New？"><a href="#What’s-New？" class="headerlink" title="What’s New？"></a>What’s New？</h2><p>假如让你上网，你最先想到的是什么？恐怕大多数人都会打开桌面上的Chrome浏览器。</p><p>然而在万维网刚开始的时候，人们使用的是蒂姆发明万维网时同时发明的万维网浏览器，名字也就叫做<em>WorldWideWeb</em>（后改名Nexus以防止混淆），这个简陋的浏览器的用户体验不是很好，既没有丰富的颜色，也不能显示图片。当时这个浏览器运行在<strong>NeXTSTEP</strong>操作系统上，而这个操作系统早已支持彩色图形化的操作界面，WorldWideWeb的界面是在引不起用户的兴趣。</p><blockquote><p>你可以在CERN的这个网站重温当年的浏览器<a href="https://worldwideweb.cern.ch/browser/">https://worldwideweb.cern.ch/browser/</a></p></blockquote><p><img src="/img/2/post12.png" alt="最早的浏览器"></p><p><img src="/img/2/post7.png" alt="用历史上第一个浏览器打开现在的百度"></p><p>于是，<strong>Mosaic浏览器横空出世，这是第一个早期普及的网页浏览器</strong>，它不仅具有更好看的界面，而且它还可以在文字中嵌入图片。并且在1993年，<strong>Mosaic推出了一个叫做What’s New的页面</strong>，这个页面几乎每天都会给公众提供一个全新网站的链接。在当时，这个页面吸引了很多人的眼球，要知道，1992年11月的时候世界上才只有26个网站，所以每一个新网站的出现都是引人注目的。</p><p>在What’s New功能出现初期，这个页面是无法自动更新的，需要靠开发者手动添加页面，来自斯特灵大学计算机系的一名毕业生乔纳森·弗莱彻（ Jonathon Fletcher）发现了这个问题，所以他发明了<em>JumpStation</em>爬虫，在1993年底，JumpStation爬遍了全世界，记录了2万5千个网页，在乔纳森为其加上搜索工具后，Mosaic的What‘s New就形成了世界上第一个网页搜索引擎。Mosaic和它的What‘s New非常辉煌，据说在当时What’s New可能是万维网上访问量最高的单个页面，在1994年，获得了最重要服务概念奖（Most Important Service Concept）。</p><p><img src="/img/2/post9.png" alt="What&#39;s New的最佳服务概念奖"></p><p><img src="/img/2/post3.jpg" alt="1993年的What&#39;s New"></p><h2 id="更多爬虫的出现"><a href="#更多爬虫的出现" class="headerlink" title="更多爬虫的出现"></a>更多爬虫的出现</h2><p><strong>93年在学术界也有崭新的爬虫出现，那就是<em>World Wide Web Worm</em>，简称<em>WWWW</em>。</strong>与之前的爬虫不一样，这个爬虫还支持正则表达式搜索。正则表达式是一种“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p><p>比如<code>[1-9]\d&#123;5&#125;(?!\d)</code>这一句正则表达式表示中国的邮政编码格式，能匹配100001这样的字符串</p><p>再比如<code>((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;)(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d&#123;1,2&#125;))&#123;3&#125;</code>这样的字符串，能匹配<code>192.168.0.1</code>这样的IP地址。</p><p>看到这你是不是已经头大了？虽然正则表达式很难被计算机小白们理解，但是在没有google之前，搜索引擎能准确的找到东西都是一个问题，虽然使用正则表达式稍微麻烦一点，但是他还是得到了很多人的喜爱。WWWW在1994年爬取到了11万个网页，并它获得了年度最佳导航网站的奖项。</p><p><img src="/img/2/post4.png" alt="WWWW最佳导航网站奖"></p><p><strong>然而WWWW和JumpStation，都遇到了一个问题，那就是数据的储存。</strong>WWWW的作者并没有能力保存下爬取到的所有数据，于是只保存了爬取到的网页的前几级标题，而JumpStation的开发者没有得到斯特灵大学的投资，即使是只保存标题，也在1994年由于缺乏资金来购买存储介质而停止了开发。（当初数据的存储器是非常非常贵的）</p><p>而*<em>休斯顿大学财大气粗，启动了</em>RBSE(Repository Based Software Engineering Program)*项目**，这个项目也开发了一个爬虫，与WWWW和JumpStation不一样，RBSE的爬虫会存储并索引HTML页面的全文，这与当下的搜索引擎更为接近。我们在搜索引擎中输入的关键词搜索到的网页更可能是与正文内容匹配，而不仅是标题，这大大提高了搜索引擎的准确率。RBSE总共获取到了100MB的数据，他们的搜索功能获得了平均每天300个访问，最高900次请求的成绩，作为一个研究项目，RSBE的成果可以是非常成功的。</p><p><strong>RBSE spider还是第一个提出注重爬虫礼仪的爬虫</strong>，上一期提到，马修写的爬虫出了问题，导致互联网出现了大拥堵，于是开发者约定了robots.txt，而RBSE提出，在访问网站的时候会在User-Agent中添加<code>RBSE-Spider/0.1</code>的字样，并且通过优化代码降低对互联网的影响。</p><p><img src="/img/2/post5.png" alt="RBSE的爬虫礼仪"></p><p><strong>接下来要介绍的爬虫成功存活到了现在，那就是<em>WebCrawler</em>。</strong></p><p><img src="/img/2/post11.png" alt="过去的webcrawler"></p><p><img src="/img/2/post8.png" alt="WebCrawler"></p><p>这个与爬虫的英文同名的爬虫在1994年爬取到了总共4000个网站，在年底，用这个爬虫构建的搜索引擎就迎来了它的第一百万次搜索。（据说第一百万次的搜索内容是“核武器的设计和研究”）比起RBSE，WebCrawler同样也能进行全文搜索，不同的是，WebCrawler比RBSE爬取的范围更大更广，而且WebCrawler能够同时下载15个网页，这意味着搜索引擎数据库更新的速度也更快。</p><h2 id="互联网泡沫"><a href="#互联网泡沫" class="headerlink" title="互联网泡沫"></a>互联网泡沫</h2><p>这个优秀的产品迅速吸引了资本的注入，在1995年，美国在线（AOL）收购了WebCrawler，然后对WebCrawler进行了商业化，即在搜索结果的边上放置广告位，通过广告位收费来盈利。在1996年，WebCrawler达到了它的顶峰，当时这个网站是是互联网上访问量第二高的网站，它的服务器甚至经常因为访问量太高而崩溃。</p><p>然而，好景不长，Inktomi开发了一个叫做Slurp的爬虫，并研发了Inktomi搜索引擎，关于这个爬虫的资料比较少，所以我也无法详细介绍，但是Inktomi与其他搜索引擎不同，他不直接提供搜索功能，而是向合作伙伴卖技术来盈利，雅虎、Infoseek、Lycos、Excite甚至微软MSN都在使用它的技术。于是，<strong>WebCrawler在竞争中处于劣势，然后几经转手，虽然现在还苟活着，但是它已经没有独立的数据库来支持搜索功能了，它成为了一个元搜索引擎</strong>。元搜索引擎和百度、Google这样的独立搜索引擎区别很大，前者的数据来源是多个独立搜索引擎甚至是其他元搜索引擎，拿到手的数据再经过自己的整理、优化然后再呈现给用户。</p><p>之后，互联网泡沫逐渐形成了，我对经济学不是很了解，但是对于上世纪九十年代美国的互联网泡沫的形成原因，大概就是那些投资人把太多的钱给了没有前景没有技术只会讲故事的互联网公司。其中Yahoo就是受到打击很严重的企业之一，Yahoo没有自己的搜索引擎技术，甚至在很长的一段时间内，它是手工对网站进行分类的，这样不牢固的基础，使得它在泡沫破裂的时候市值蒸发了90%。</p><p><img src="/img/2/Nasdaq_Composite_dot-com_bubble.svg" alt="纳斯达克指数，互联网泡沫"></p><p>总结一下这场泡沫，那就是对于搜索引擎和爬虫领域，没有足够强技术的WebCrawler没落了，没有自己技术的Yahoo失败了，反倒是有技术但是不直接和消费者打交道的Inktomi生存下来了，由此可见，科学技术还是非常非常重要的，咱们只有掌握了核心的技术才能在大风大浪来临时稳操胜券。</p><h2 id="Google"><a href="#Google" class="headerlink" title="Google"></a>Google</h2><p>虽然20世纪末的互联网泡沫破裂导致了一大堆.com公司倒闭，但是存活下来的公司大多到如今都成为了互联网界闪耀的明星，比如Amazon、eBay、PayPal、Netflix，最具代表性的当然还有我们接下来要介绍的Google，在这些公司当中，Google的日子算是过的最好的，它在泡沫期间不仅几乎没有受到负面影响，甚至在泡沫爆破后还能进行公开招股。这和他们的经营方法有关系，也和Google爬虫的强大技术有关系。</p><p>Google的最初版本是由斯坦福大学的拉里·佩奇和谢尔盖·布林开发的，Google这个词起源于Googol，也就是$10^{100}$这个数字，他们想让自己的搜索引擎能够大到Googol这么大，于是，他们又带了一位斯坦福的博士同学克雷格·希尔福斯坦出去创业。</p><p><strong>Google搜索的爬虫从开始就被设计成为一个大范围的、通用的网络爬虫</strong>。当时的技术对于查找到万维网上的资源已经不是个很大的问题，但是可能出现搜索某个关键词，出来的结果十条只有两三条是相关的情况。甚至当时冒出的很多搜索引擎为了节约存储资源，不仅不爬取网页全文，连标题也不爬全，对于虚词（to not be）不做索引，结果这些搜索引擎对于莎士比亚的那句话“To be or not to be”的搜索结果就是空。而Google可以做到十条结果能有七八条是相关的，而且能够搜索到“To be or not to be”。</p><p><img src="/img/2/post10.jpg" alt="90年代的Google"></p><p><strong>Google的爬虫在存储、搜索、爬取三方面做出了创新：</strong></p><ul><li><p>之前其他爬虫遇到的问题，Google爬虫也遇见了，那就是数据的存储问题，Google为了保证搜索的准确性，肯定也是进行网页全文爬取的，它对存储过程进行了大量的底层优化，包括将爬取到的网页进行压缩后存储、并创建索引来减少磁盘访问时间。</p></li><li><p>Google爬虫在搜索算法方面发明了一个存活至今的叫做PageRank的算法，其基本假设是：<strong>更重要的页面往往更多地被其他页面引用。</strong>这个算法将互联网的网页看做节点，将超链接看做边，形成一张非常大的有向图，指向某个网页的超链接被看做对这个网页的“投票”，而这种“投票”的权重由超链接所存在的网页权重有关。假如一个非常热门和权威的网页上出现了你的网站的链接，那么你的网页权重就会升高，假如有非常多的网站都出现了你网站的链接，那么你的网页权重也会升高。虽然目前该算法早已不再是Google用来给网页排名的唯一算法，但它是最早的，也是最著名的算法。</p><p><img src="/img/2/post2.png" alt="PageRank算法"></p><p>我们有的时候能在一些网站底部看见一些超链接，这些被称作友情链接，网站的站长们为了让自己的网站在搜索引擎中能排的更前，会与其他网站的站长商量，在网页不起眼的地方互相加上网站的链接，这就是根据PageRank算法所耍的小聪明。</p><p><img src="/img/2/post6.png" alt="阿里云网站的页面底端"></p></li><li><p>在爬取速度方面，Google使用了主从式爬虫架构（Master-Slave），这种架构的核心思想就是“分而治之”，<strong>自此，爬虫从单一作战成功进化成群体进攻</strong>。主从式架构的主服务器（master）将一个原始的大任务分解成一系列小任务，然后分配给子服务器（Slave）执行，然后再主服务器收集产生的结果。这种架构虽然不是最佳的解决方案，但是<strong>在当时Google做到了每秒100个页面的下载速度。</strong></p><p><img src="/img/2/post1.png" alt="主从式架构"></p></li></ul><h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>爬虫已经完成了第一阶段的进化，它们在搜索引擎中发挥巨大作用，它们帮助Google度过互联网泡沫，它们开始成群结队有纪律地向万维网发起进攻，然而，随着爬虫的威力越来越强，万维网的规模也在逐渐加大，那座传说中的互联网冰山正在形成，爬虫能将他的魔掌伸向冰川之下吗……</p><div class="note note-info">            <p>这篇文章也发布在下面这个公众号数媒极客，公众号里面有其他很有趣的文章，可以扫码看一看~</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/671DEC2D0C09137F94251F74940B395C.jpg" style="zoom:50%;" />          </div>]]></content>
    
    
    <categories>
      
      <category>爬虫历史系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络爬虫进化史，原来你是这样的爬虫：第1期</title>
    <link href="/2021/02/21/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%9A%E7%AC%AC1%E6%9C%9F/"/>
    <url>/2021/02/21/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E8%BF%9B%E5%8C%96%E5%8F%B2%EF%BC%8C%E5%8E%9F%E6%9D%A5%E4%BD%A0%E6%98%AF%E8%BF%99%E6%A0%B7%E7%9A%84%E7%88%AC%E8%99%AB%EF%BC%9A%E7%AC%AC1%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="网络爬虫进化史，原来你是这样的爬虫：第1期"><a href="#网络爬虫进化史，原来你是这样的爬虫：第1期" class="headerlink" title="网络爬虫进化史，原来你是这样的爬虫：第1期"></a>网络爬虫进化史，原来你是这样的爬虫：第1期</h1><h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p><img src="/img/1/post6.png" alt="image-20200930210703651"></p><p>2020年的一个平淡的一天，累了一天的你打开手机，发现满朋友圈的“手把手教你写Python爬虫爬取小姐姐照片”广告，有没有疑惑过爬虫究竟是个啥？怎么突然就这么火了？</p><p>接下来这个系列的文章将会告诉你，爬虫是如何从一只小虫，变成布满整个互联网、在所有人面前张牙舞爪的可怕巨虫的。</p><h2 id="出生之前"><a href="#出生之前" class="headerlink" title="出生之前"></a>出生之前</h2><p>我们的故事要从1989年的瑞士开始。在瑞士日内瓦西部与德国的边境处有一片荒野，在这片荒野里，一群智商高达250的精英们躲在这偷偷研究世界上最小的物质——这里建立着世界上最大的粒子物理学实验室：欧洲核子研究委员会（CERN）。八十年代，切尔诺贝利事故的阴影笼罩在整个欧洲上空，然而年轻的<strong>蒂姆·伯纳斯·李（Timothy John Berners-Lee）</strong>和其他CERN的科学家们却没有停下脚步，仍然在继续研究。</p><p>话说这蒂姆并不是很有名气的资深教授，CERN的研究也轮不上他，但是Boss也不能让他闲着，看蒂姆的爸妈都参与了第一台商业电脑<strong>曼切斯特1型（Manchester Mark I）</strong>的发明，就让他开发个计算机软件，目的能让CERN与其他国家的研究室更加便捷地交流。</p><p>蒂姆虽然拿到了牛津的荣誉物理学士学位，本该研究物理，但是他还是接了这项工作。令人出乎意料的是，不久之后，在1989年的夏夜，世界上第一个Web服务器和客户端出现在了CERN的一台NeXT计算机上。<strong>他将这项技术命名为World Wide Web，也就是www，或者叫做万维网，从此，互联网的青春开始了。</strong></p><p><img src="/img/1/post2.jpg" alt="万维网的诞生机器"></p><p>等等，你不是要讲爬虫吗，怎么讲起万维网来了？</p><p>别急，蒂姆发明万维网的同时，还带来了三项关键的技术，这三项技术为爬虫的诞生构建了温床，那就是<strong>URI、HTML和HTTP</strong>。</p><p>先说最基础的http吧，这个大家应该不陌生，你打开浏览器访问任何网页的时候，看网址开头都是<code>http://</code>。爬虫说到底还是一堆0和1，它们靠着http在万维网中伸展拳脚。</p><p>之后就是URI，用来精确定位互联网上的资源，简单说就是咱们说的网址，网址各部分的意思如图所示，通过一堆字符确定了服务器、端口、路径、内容和传送的方式，爬虫靠着他提供的“地址”敲响每个服务器的门。</p><p><img src="/img/1/post10.jpg" alt="URL"></p><p>最后就是HTML，这是与爬虫联系最精密的一项技术。HTML是超文本标记语言，作家写文章的时候可能会给编辑留下一些非正文的消息，比如</p><blockquote><p>作家：</p><p>……我家门口有两棵树，其中一棵是枣树，另一棵也是枣树。（注：这两棵树品种不同）……</p><p>编辑：</p><p>把括号里的文字放在书的最下方，并用小号字体标注是注释，正文中删去括号中的话。</p></blockquote><p>HTML就是作家写的原文，网页编写者通过<code>&lt;h&gt;&lt;/h&gt;</code>这样的标签对来标记文章的内容，然后咱们优秀的编辑——浏览器把这些标签解释出来，然后形成你现在正在看的这个网页。有了这些标签，你就能看见这些有<strong>粗体</strong> <em>斜体</em> <font size="5">大</font><font size="2">小<font color="#dd0000">颜色</font></font>不同的字了。这让人们能把他们宝贵的知识放到网上共享，也能让你天天在微信发各种各样的朋友圈，而这些有用的数据就是爬虫的<strong>最终目标。</strong></p><p>值得一提的是，HTML有一种特殊的标签<code>&lt;a&gt;</code>，被这个标签标记的文本会被认为是一个<strong>超链接</strong>，超链接的发明，让阅览网页与阅读书籍产生的本质上的区别，这是一种<strong>“所见即所得”</strong>的体验，比如这篇推送的“阅读原文”，你只要动动手指点一下阅读原文就能跳转页面过去，而不是从书架上翻一本新的书。超链接就像虫洞一样，爬虫靠着这个完美的交通工具，在万维网上爬来爬去。</p><h2 id="万维网需要爬虫"><a href="#万维网需要爬虫" class="headerlink" title="万维网需要爬虫"></a>万维网需要爬虫</h2><p>之前我们说到那蒂姆发明了万维网，在1991年这项技术被公之于众之后，它可是成了当时的“网红”，1993年只有130个网站，1996年就有十万个了，1993年Web服务器占比1.5%，1996年就已经有50%的服务器是Web服务器了。如此快的增长速度，也伴随着巨量的数据，而数据一多，要找到特定的数据就尤为困难。假如你想知道爬虫是啥，你可能打开电脑首先就百度去，可是当时的人没有搜索引擎，他们使用一种类似黄页的东西，要查询到爬虫是啥，他们可能会选择从厚厚的书中找到某生物研究机构的主页，然后在控制台敲上网址，然后访问（虽然结果还是无功而返）。</p><p><img src="/img/1/post7.png" alt="碟中谍1"></p><p>其实在万维网发布之前就出现了第一个搜索引擎——<strong>Archie</strong>，不过它与百度谷歌相差甚远，它只是一个搜索匿名ftp下载服务器的脚本。ftp是文件传输协议，在万维网出现之前就已经流行起来，即使是当下也有很多文件是通过ftp协议下载的。Archie虽然叫做搜索引擎，但是搜索功能很蛋疼，用户搜索的每个字都必须要精确符合标题才可以搜索到结果，但即使功能如此简陋，但是在其巅峰时期，使用这个引擎的流量占据蒙特利尔总带宽的50%。</p><p><img src="/img/1/post1.jpg" alt="Archie"></p><p>Archie体现了搜索引擎的需求，而开发者们选择了两种方式来开发搜索引擎：</p><p><strong>马丁·科斯特（Martijn Koster）的尝试是ALIWEB</strong>，这是最早的万维网搜索引擎之一，于1993年12月发布，ALIWEB的数据来源是用户的主动提交，它允许网站站长上传他们网站的URL，并手动添加描述，之后用户就可以通过ALIWEB查询到对应的网站。然而，来提交网站的站长并没有马丁想象的那么多，有的可能不知道如何提交，有的可能懒得提交，有的可能根本就不知道这个网站，所以ALIWEB就这样慢慢的消失在了互联网的发展长河中。</p><p><img src="/img/1/post5.png" alt="ALIWEB在1997年的页面"></p><p><strong>而另一波开发者选择了一个更聪明的数据获取方式，他们准备发明一个能够自动环游万维网的探索者，主动去探索万维网，获取网站的信息，再通过算法索引它们来建立搜索引擎，这样就不需要被动的等待站长们来提交网页了。</strong></p><p>然而他们都没有想到，这是一个潘多拉宝盒，这个探索者转眼间就变成了依附于万维网上的爬虫。在三十年后的今天，这些爬虫密密麻麻地分布在网络上，互联网的每个角落都有爬虫的身影，即使是冰山底下的暗网也被特殊的爬虫涉足，据传言，<strong>互联网上50%的流量都是爬虫创造的</strong>，也许人们称这项技术为“爬虫”时就已经潜意识认为这项技术像爬虫一样，虽然无害甚至有益，但总是让人恐惧。</p><p><img src="/img/1/post3.png" alt="传统爬虫结构"></p><p>工程师们最初设计的传统爬虫的结构由图中这几部分组成，这是一个很简单的架构，简单来说就是获取网页-&gt;提取网页的数据和连接-&gt;从新获取的连接中获取新网页。</p><p>我们可以把爬虫想象为一位攻城掠地的常胜将军，他带着初始的补给去攻打一个个城池，每攻下一个城池就能获得新的补给，然后他就带着新的补给去攻打新的城池……直到他征服了全世界。</p><p>然而，有的将军脑子不是那么灵光，他走到一个城池地下，在脑子里想半天才能回忆起来这个城池是否已经攻略，还有的将军的战略不太好，攻下一个城池的时间过于久，以至于他一辈子也征服不了世界。这些都是常胜将军的训练员——爬虫工程师们将要解决的问题。</p><h2 id="初露锋芒"><a href="#初露锋芒" class="headerlink" title="初露锋芒"></a>初露锋芒</h2><p>虽然爬虫的需求是依附于搜索引擎的，但是世界上第一个爬虫程序并不是用于搜索引擎的。</p><p>在万维网成为“网红”并展示其惊人的发展速度后，<strong>MIT的一位学生，马修·格雷（Matthew Gray），决定研究一下万维网的拓张速度，于是他在1993年写下了历史上第一个爬虫——<em>World Wide Web Wanderer</em>。</strong></p><p>马修使用了当时热门的Perl语言来编写这个爬虫，爬虫会生成一个叫做Wandex的Web数据库，这个数据库里存储着爬取到的所有URL和服务器，只要稍加改进，这个数据库就能成为搜索引擎，比雅虎和谷歌早了好多年。然而马修只想着他的课题——研究万维网的拓张速度，并没有兴趣开发搜索引擎。</p><p><img src="/img/1/post9.jpg" alt="然而这位马修·格雷在2017年还是去了谷歌工作"></p><p>马修的爬虫引起了许多人的关注，早期的代码也在互联网上广泛流传，然而还是学生的马修写出的代码出现了严重的bug，再加上许多人同时运行这个爬虫，导致相同的一个页面一天被访问上百次，在带宽不高的当时，这样的访问直接让几个服务器宕机了。隔壁ALIWEB的马丁立刻在万维网开发者的讨论区——www-talk中喷了一波爬虫，并且提议设立<strong>机器人排除标准（Robots Exclusion Standard）</strong>，又叫做robots.txt。这是历史最悠久并存在至今的反爬虫技术。</p><p><img src="/img/1/post8.jpg" alt="Robots.txt介绍"></p><p><img src="/img/1/post4.png" alt="百度的部分robots.txt，图中禁止了百度自家爬虫爬取自己"></p><blockquote><p>可怜的爬虫技术，自其一出生就遇见了死对头，爬虫与反爬虫从此开始了道高一尺魔高一丈的斗争。爬虫的合法性常常被人质疑，俗话说“爬虫写得好，牢饭吃得早”，由于反爬虫技术越来越强，反反爬虫技术也一直革新，而反反爬虫有被认为是非法盗取信息以及侵犯隐私的嫌疑，于是许多爬虫开发者都游走在灰色区域。在国外非常著名的案件有eBay VS. Bidder’s Edge案，在国内有百度起诉360搜索案，然而这都是后话……</p></blockquote><p>robots.txt是什么呢，其实并不是什么高级的技术，只是在网站的根目录下的一个普通txt文档而已。与其说它是网站的高大城墙，不如说它是酒店房间门口挂的“请勿打扰”，站长可以通过编辑robots.txt来指定爬虫能爬取哪些页面，或者指定哪些不道德的爬虫不允许来爬取这个网站，但是这些规则都不是强制性的，爬虫技术上完全可以无视这些规则。</p><h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>1993年和1994年是爬虫发展最为迅速的两年，许多爬虫的开发都是同时进行的，几乎每个月都能有新的爬虫出现，一张大网已经为织好，接下来，就有请它们闪亮登场吧……</p><div class="note note-info">            <p>这篇文章也发布在下面这个公众号数媒极客，公众号里面有其他很有趣的文章，可以扫码看一看~</p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/671DEC2D0C09137F94251F74940B395C.jpg" style="zoom:50%;" />          </div>]]></content>
    
    
    <categories>
      
      <category>爬虫历史系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
