

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head><!-- hexo injector head_begin start -->
  <script src="/js/Chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script>
<!-- hexo injector head_begin end -->
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/avatar.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="简简单单翻译这篇论文，可能有错误，仅供参考。原文第五章Evaluating KEPLMs由于兴趣不足没有翻译。参考文献的序号并没有全部标上，详细可以看原文。">
  <meta name="author" content="Kamino">
  <meta name="keywords" content="Kamino">
  <meta name="description" content="简简单单翻译这篇论文，可能有错误，仅供参考。原文第五章Evaluating KEPLMs由于兴趣不足没有翻译。参考文献的序号并没有全部标上，详细可以看原文。">
<meta property="og:type" content="article">
<meta property="og:title" content="《知识增强的预训练语言模型》论文简单翻译">
<meta property="og:url" content="http://blog.kamino.link/2023/01/03/%E7%9F%A5%E8%AF%86%E5%A2%9E%E5%BC%BA%E7%9A%84%E9%A2%84%E8%AE%AD%E7%BB%83%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E8%AE%BA%E6%96%87%E7%AE%80%E5%8D%95%E7%BF%BB%E8%AF%91/index.html">
<meta property="og:site_name" content="Kamino&#39;s Blog">
<meta property="og:description" content="简简单单翻译这篇论文，可能有错误，仅供参考。原文第五章Evaluating KEPLMs由于兴趣不足没有翻译。参考文献的序号并没有全部标上，详细可以看原文。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103144456.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103153623.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103165922.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104172659.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104174304.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104174749.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104181421.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104182110.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104184307.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104192532.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104193034.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104194549.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107162802.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107190839.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107192110.png">
<meta property="og:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107192128.png">
<meta property="article:published_time" content="2023-01-03T05:14:00.000Z">
<meta property="article:modified_time" content="2023-01-07T12:06:49.163Z">
<meta property="article:author" content="Kamino">
<meta property="article:tag" content="PLM">
<meta property="article:tag" content="Knowledge-Enhanced">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103144456.png">
  
  <title>《知识增强的预训练语言模型》论文简单翻译 - Kamino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.kamino.link","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"4a5b4b79f797585f54a6f176ffa56438","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Kamino</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://kamino-img.oss-cn-beijing.aliyuncs.com/20211020151909.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="《知识增强的预训练语言模型》论文简单翻译">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2023-01-03 13:14" pubdate>
        2023年1月3日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      12k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      38 分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">《知识增强的预训练语言模型》论文简单翻译</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2023年1月7日 晚上
                
              </p>
            
            <div class="markdown-body">
              <h1 id="《知识增强的预训练语言模型》论文简单翻译"><a href="#《知识增强的预训练语言模型》论文简单翻译" class="headerlink" title="《知识增强的预训练语言模型》论文简单翻译"></a>《知识增强的预训练语言模型》论文简单翻译</h1><p>论文链接：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/2212.13428">A Survey on Knowledge-Enhanced Pre-trained Language Models (arxiv.org)</a></p>
<p>简简单单翻译这篇论文，可能有错误，仅供参考。原文第五章Evaluating KEPLMs由于兴趣不足没有翻译。参考文献的序号并没有全部标上，详细可以看原文。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>预训练语言模型（PLM）指的是先在一个大数据集上训练，然后直接迁移到下游任务或者进一步在小数据集上微调的NLP模型。早期的PLM如Skip-Gram、GloVe是浅神经网络，他们从窗口上下文（window-sized context）中学习到的词嵌入是静态的向量，无法处理动态环境中的一词多义。随着深度学习的发展，研究者尝试深度学习+动态语义嵌入的方式来提升：最开始限制于监督学习，没有发挥深度学习充分的潜力；然后随着自监督模型如BERT的出现，大预言模型能够从大规模无标签的文本中通过预测被mask掉的token的方式学到许多知识，从而在NLP取得了突破。自此，许多使用Transformer+自监督来解决NLP问题的方法被提出，逐渐PLM进入了快速发展阶段，最新的现象级的成果就是OpenAI的ChatGPT。</p>
<p>虽然研究取得了进步，但是PLM仍然具有<strong>较弱的可解释性、健壮性和推理能力</strong>：PLM就像黑盒一样难以解释；PLM可能遭到对抗攻击，健壮性不够；还有就是PLM完全是数据驱动的，限制了推理能力。以上这些缺陷可以通过知识增强的预训练语言模型（Knowledge-Enhanced Pre-trained Language Models, KEPLMs）来改进。</p>
<p>虽然已经有一些KEPLM的综述，但是这个领域发展很快，本文旨在提供综合、最新、多角度的综述。</p>
<p>本文第二章介绍KEPLM的背景，第三章介绍常用的知识种类和格式，第四章介绍构建KEPLM的多种方法，第五章介绍可能的衡量指标，第六章介绍在要用到许多知识的下游任务中的应用，第七章介绍未来研究方向，最后一章总结。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>这一章先介绍PLM的概念，然后介绍最近PLM+Knowledge的趋势。</p>
<h3 id="PLM"><a href="#PLM" class="headerlink" title="PLM"></a>PLM</h3><p>2013年word2vec开启了PLM的时代。第一代PLM有Skip-Gram、GloVe，它们企图直接从下游任务中获得词嵌入，由于算力问题，并且它们的模型架构通常都比较简单。第二代PLM如基于LSTM的CoVe[53]和ELMo[54]还有BERT和GPT，专注于通过动态上下文来得到词嵌入。这一时期Transformer成为了NLP领域的热点，几乎所有明显的突破都使用了它。现今，PLM通常指Transformer架构的模型，在预训练-微调的范式下的模型。典型的PLM包括GPT（Transformer的解码器）、BERT（编码器）、BART（解码器和编码器）。最近，prompt learning，一个NLP中的新范式，正在变得火热[57]，它可以更好地使用PLM的知识，并给予PLM在few-shot和zero-shot这些困难场景下的能力。</p>
<h3 id="Knowledge-PLM"><a href="#Knowledge-PLM" class="headerlink" title="Knowledge+PLM"></a>Knowledge+PLM</h3><p>在Knowledge和PLM的结合中，有两条研究线路：第一条是<strong>将PLM作为知识库</strong>（Knowledge Bases, KB），第二条是<strong>通过知识来增强PLM</strong>。本文更着重后者。</p>
<h4 id="将PLM作为知识库"><a href="#将PLM作为知识库" class="headerlink" title="将PLM作为知识库"></a>将PLM作为知识库</h4><p>知识库（如Wikidata和ATOMIC等）储存了实体和实体间关系，通常以关系三元组的形式呈现。PLM则是相较于结构化知识库而言的一种替代。从LAMA[59]开始，许多研究者探索了PLM能否当做结构化知识库。文献[60]探索了如何使用PLM自动构建结构化知识库，文献[61]探索了神经网络中准确度和内存容量的关系，论证了PLM可以被用作知识库。文献[62]说关系化知识库可以更正确地表示知识，但是缺乏灵活性。作为对比，文献[63]探索了PLM和知识库各自的优缺点，他们相信具有显性知识的知识库无法完全被具有隐性知识的PLM代替。文献[64]发现closed-book问答对于生成模型来说还是一个挑战，所以生成模型并不适合作为KB。文献[65]认为PLM要在5个方面表现好才能作为知识库，并且5个中有3个方面知识库比PLM更好。</p>
<h4 id="通过知识来增强PLM"><a href="#通过知识来增强PLM" class="headerlink" title="通过知识来增强PLM"></a>通过知识来增强PLM</h4><p>另一方面，我们可以通过知识来增强或者扩展PLM。在许多要用到知识的下游任务中（比如QA任务），增加PLM的参数量可以提升其学到的知识。然而，增加参数来学习知识的操作的效率并不是那么高，比不上直接结合知识。所以，研究如何将知识嵌入PLM中是一个需要研究的方向。</p>
<p>如ERNIE[67]、KnowBert[68]、K-BERT[69]的方法是早期通过知识来增强PLM的方法，他们在要用到知识的下游任务中取得了成功。许多接下来的模型受其启发，现今，更多的KEPLM正在出现，通过不同的方法结合各种知识，并在各种任务上进行尝试。</p>
<h2 id="KEPLM的知识来源"><a href="#KEPLM的知识来源" class="headerlink" title="KEPLM的知识来源"></a>KEPLM的知识来源</h2><p>这一章对要融合进PLM的知识的种类和格式进行叙述。</p>
<h3 id="知识的种类"><a href="#知识的种类" class="headerlink" title="知识的种类"></a>知识的种类</h3><p>分成五类分类叙述：语言学知识、语义知识、常识知识、百科知识、特定领域内知识。</p>
<h4 id="语言学知识"><a href="#语言学知识" class="headerlink" title="语言学知识"></a>语言学知识</h4><ul>
<li>Part-of-Speech Tags：常用的tag包括名词、动词、副词等，这个可以帮助理解自然语言。在语义情感分析中，SentiLARE[70]就使用了这方面知识。</li>
<li>句法结构：通过句法分析获得句子的结构知识，比如单词间的依赖和支持。Syntax-BERT[71]使用了这方面知识，构建了句法树。K-Adapter[72]结合了依赖解析信息（dependency parsing information），提升了依赖关系预测任务。</li>
<li>跨语言迁移性：PLM可以通过多语言语料学习到多语言的迁移能力，XLM-K[73]证明了一个语言的语言学知识可以帮助其他语言的学习。</li>
</ul>
<h4 id="语义知识"><a href="#语义知识" class="headerlink" title="语义知识"></a>语义知识</h4><p>语义知识旨在帮助模型理解文本的含义，比如KT-NET[74]、SenseBERT[75]、LIBERT[76]引入了WordNet的语义知识，分别在机器阅读理解、缩句、多义词分析（word sense disambiguation）取得进展。文献[78]将句法树通过VerbNet转换成了对应的语义，从而模型能够理解文本。SemBERT[80]通过语义角色标签来获取语义知识，从而改进阅读理解和语言推理的效果。</p>
<h4 id="常识知识"><a href="#常识知识" class="headerlink" title="常识知识"></a>常识知识</h4><p>常识指的是日常人们每天关于世界和活动的知识[81]，常用的常识知识库如图1。常识在知识库中使用三元组表示，其节点更多为短语而非单词，与百科知识不同。举例来说，一个三元组可能是<code>*having no food, CauseDesire, go to a store</code>，而一个百科知识可能是<code>China, capital, Beijing</code>。</p>
<p>表1所示，<strong>ConceptNet</strong>是最常用的开源常识库，其包含34种关系，比如<code>RelatedTo</code>、<code>IsA</code>等，在QA、常识验证、常识故事生成任务中常用。<strong>ATOMIC</strong>则是一种基于<code>if-then</code>的推理关系，比如<code>if X pays Y a compliment, then Y will likely return the compliment</code>，包含了causes vs. effects,<br>agents vs. themes, voluntary vs. involuntary events, and actions vs. mental states（啥？不会翻译了）。这在常识推理、常识QA任务中比较有用，如文献[23]和[27]。<strong>ATOMIC</strong>$^{20}_{20}$包含了更准确更多样的常识，包括社交、物理和一些以某事件为中心的类别。文献[29]将其中的三元组转换成自然语言来预训练，提升了因果分类和常识QA任务的效果。<strong>ASER</strong>是大规模eventuality的知识图谱，事件作为节点，语句关系作为边，比如一个因果关系的两个节点：<code>Jim yells at Bob</code>、<code>Bob is upset</code>。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103144456.png" srcset="/img/loading.gif" lazyload alt="图1"></p>
<h4 id="百科知识"><a href="#百科知识" class="headerlink" title="百科知识"></a>百科知识</h4><p>百科知识包括了公开范围的广泛的信息，以文本或者三元组的形式存在。Wikipedia是一个多语言的非结构化的百科，BERT就使用了其作为预训练数据来学习，而其他方法通常利用三元组形式的百科知识。</p>
<p>Wikidata是百科知识中的最广泛使用的知识图谱，一些KEPLM（K-Adapter、ERNIE、KgPLM、ERICA）就使用了Wikidata作为知识来源。其他常用的英文百科知识图谱包括Freebase、DBpedia、NELL。CN-DBpedia则是一个常用的中文百科知识图谱。用在中文的下游任务的KEPLM有K-BERT[69]，其就使用了CN-DBpedia。</p>
<p>Wikidata5M是KEPLER提出的一个大规模知识图谱，其不仅包含三元组，还包含实体和关系的高质量描述，KEPLER自己利用这些描述来初始化knowledge mebedding，CoLAKE同样也使用了这个方法。</p>
<h4 id="特定领域内知识"><a href="#特定领域内知识" class="headerlink" title="特定领域内知识"></a>特定领域内知识</h4><p>相较于百科知识，特定领域内的知识更具体，比如医学、电商等领域，如表2总结。</p>
<p>生物医学的知识通常用症状或者疾病的三元组表示，比如<code>bacterial pneumonia, with associated morphology, inflammation</code>。电商领域的知识则是由商品名称组成，它们的描述用一系列短语构成。比如<code>iPhone XS is described as iOS; 4G signal; T-Mobile service; OLED screen; ...</code>。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103153623.png" srcset="/img/loading.gif" lazyload alt="表2"></p>
<h3 id="知识格式"><a href="#知识格式" class="headerlink" title="知识格式"></a>知识格式</h3><p>总共有四种常用的格式：实体词典、知识图谱、纯文本、有标签的图像。</p>
<h4 id="实体词典"><a href="#实体词典" class="headerlink" title="实体词典"></a>实体词典</h4><p>为了将实体中的知识融入，我们需要将实体的知识嵌入集成到对齐的token嵌入中。现有模型通过两种方法来初始化实体的嵌入，第一种是通过传统的知识嵌入算法（比如TransE，文献ERNIE和CokeBERT使用），第二种是通过编码实体的描述（文献KEPLER）。</p>
<p>第一种方式能够融合邻居节点，但是要面临heterogeneous embedding space的问题，因为文本的特征空间和知识图谱中实体的特征空间是不一致的。第二种方法在相同空间中融合，但是实体嵌入可能不能完全表示实体的含义。</p>
<p>以实体嵌入的形式注入知识既简单又直观。但是，当知识图谱更新时，实体嵌入需要再训练，并且如果在是在预训练阶段融入的知识，则模型也必须再进行训练。</p>
<h4 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h4><ul>
<li>三元组：为了融合三元组形式的知识，可以像K-BERT[69]、ERNIE 3.0[91]、文献[11]和[92]那样将三元组放进文本中合适的位置。或者也可以像文献[93]中融入三元组的嵌入。</li>
<li>子图：知识子图是知识图谱的一部分，QA-GNN[12]、GreaseLM[13]、KG-BART[17]和KALA[94]就使用了子图的方法，在4.2.2节中详细介绍</li>
</ul>
<h4 id="纯文本"><a href="#纯文本" class="headerlink" title="纯文本"></a>纯文本</h4><p>为了融合文本格式的知识，我们可以将知识三元组转换成句子作为预训练阶段的语料，或者也可以添加相关的实体定义。常识知识三元组比较适合转换成句子。比如：文献[29]把三元组<code>(PersonX accidentally fell, xEffect, PersonX breaks an arm)</code>转换为<code> “Tracy accidentally fell. As a result, Tracy breaks an arm.”</code>，然后在预训练阶段将其作为输入。</p>
<p>Dict-BERT[95]还将稀有词汇的定义添加到了文本末尾作为模型的输入，这也令模型在稀有词汇的学习提升了，但是并不适用于多义词。</p>
<h4 id="有标签的图像"><a href="#有标签的图像" class="headerlink" title="有标签的图像"></a>有标签的图像</h4><p>不同于上述形式，视觉上的知识可以通过图片来学到，为了融入视觉知识，模型可以先检索出与上下文有关的图像，然后编码并结合其与文本的嵌入，比如VALM[96]（图2）。视觉知识还可以通过图文对齐的训练目标嵌入进，比如Vokenization[97]。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230103165922.png" srcset="/img/loading.gif" lazyload alt="图2"></p>
<h2 id="搭建KEPLM"><a href="#搭建KEPLM" class="headerlink" title="搭建KEPLM"></a>搭建KEPLM</h2><p>搭建KEPLM可以将外部知识显式、隐式或二者皆有地集成进模型中。</p>
<h3 id="隐式知识集成"><a href="#隐式知识集成" class="headerlink" title="隐式知识集成"></a>隐式知识集成</h3><h4 id="知识引导的Mask策略"><a href="#知识引导的Mask策略" class="headerlink" title="知识引导的Mask策略"></a>知识引导的Mask策略</h4><p>BERT类的PLM一般使用如Wikipedia一样的非结构化的文本作为预训练的语料。这些非结构化文本数据包含丰富的上下文语义信息，BERT可以通过Masked Language Modelling（MLM）从中学到词汇的上下文知识。然而，文本中实体和短语所包含的宝贵信息却被忽略了。通过采用知识引导的Mask策略而非对单个单词的Mask策略，PLM能够学到更多关于短语和实体的知识。如图3。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104172659.png" srcset="/img/loading.gif" lazyload alt="图3"></p>
<p>ERNIE模型就在BERT的基础上添加了实体级别和短语级别的mask策略，并以此引导了BERT在与徐娜林中学到更多知识。SKEP提出了mask情感词汇的方法，可以注入情感知识。</p>
<p>与ERNIE和SKEP不同，GLM使用了知识图谱来分配给重要实体更高的mask权重。具体来说，GLM以20%的概率mask普通词汇，80%的概率mask一个实体。当GLM需要mask实体时，那些可以在ConceptNet中通过一定跳数通向其他实体的实体将会被认为是更重要的实体，并且会以更高的概率进行mask。如图4，左边这4个实体中，<code>sick</code>、<code>baby</code>、<code>cry</code>可以互相连通，但<code>sometimes</code>不能，所以会像右边这样分配概率。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104174304.png" srcset="/img/loading.gif" lazyload alt="图4"></p>
<p>与其使用一个预定义的概率，E-BERT[40]还提出了一种自适应的mask策略，允许模型能够在单词级别和短语级别的mask策略间进行切换。如图5所示，当$r&lt;\alpha$时进入word masking模式，反之则进入phrase masking模式，$r$是每次迭代随机生成的一个数字。这两种模式在一次迭代中得到的loss会被用来监测word级别和phrase级别的拟合程度，拟合程度用$\eta_w$和$\eta_p$表示，而$r^t=\frac{\eta_w}{\eta_p}$表示下一轮两种拟合的相对重要程度，并通过$\alpha=tanh(r^t)$来计算下一轮的$\alpha$。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104174749.png" srcset="/img/loading.gif" lazyload alt="图5"></p>
<h4 id="知识关联的预训练任务"><a href="#知识关联的预训练任务" class="headerlink" title="知识关联的预训练任务"></a>知识关联的预训练任务</h4><p>有的时候如图6这么弄，添加知识关联的预训练任务。举例来说，KALM[99]在输入序列中添加实体的信号，然后增加一个实体预测的预训练任务，从而帮助模型更好地学习到实体的信息。KEPLER[88]添加了知识嵌入的预训练任务，其与MLM共享同一个Encoder，从而同时获取文本增强的知识嵌入和知识增强的PLM。Vokenization[97]提出了voken的概念，即visualized token，其添加了voken分类任务，预测图像对应的voken，从而用视觉知识增强PLM。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104181421.png" srcset="/img/loading.gif" lazyload alt="图6"></p>
<h3 id="显式知识集成"><a href="#显式知识集成" class="headerlink" title="显式知识集成"></a>显式知识集成</h3><p>有三种方式来显式集成外界知识：修改模型输入、添加知识融合模块、使用外部记忆。前两种方式以额外的输入或者额外的模块向PLM中插入相关的知识，如图7中的①和②。第三种方式则保持文本和知识空间相互独立，可以促进知识的更新。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104182110.png" srcset="/img/loading.gif" lazyload alt="图7"></p>
<h4 id="修改模型输入"><a href="#修改模型输入" class="headerlink" title="修改模型输入"></a>修改模型输入</h4><p>一些KEPLM在预训练阶段插入知识三元组或者实体描述。ERNIE3.0[91]将相关的三元组添加在输入句子的末尾作为扩充的输入。K-BERT则将相关三元组注入每句话中，并生成一个语句树。若输入句子有实体<code>apple</code>，则其将从知识图谱中找到其邻居，并添加进来形成一个新的语句树，一个visible matrix还会被创建来控制知识噪声的级别。文献[11]则在此基础上改进了visible matrix来减知识噪声的引入。CoLAKE[89] 还在输入中引入了三元组，将文本看做是一个全连接的词汇图，并将知识图添加进去，形成一个混合图。其从K-BERT中获得灵感，并一定程度上减小了知识噪声。针对QA任务，文献[92] 将多个和问题有关的三元组通过预定义的模版转换成文本，并与问题和可选回答一起送入模型来训练，这在常识QA中获得了很好的表现。对于以上提到的方法，外部知识的引入可能损害原有的句子结构，所以必须要想办法在此过程中减少知识噪声。</p>
<p>同时也有一些方法以实体的形式融入知识。Dict-BERT[95] 通过Wikitionary获得句子中稀有词汇的定义，并将其添加到句子末尾。相似地，DKPLM[101] 专注于实体的长尾问题，并通过pseudo token来替换长尾实体，pseudo token从相关的三元组中获得。WKLM与这些方法不同，其用相同类型的实体来替换文本中的一些实体，然后模型需要分辨哪些是被替换的。这个方法没有修改模型，只是修改了预训练时的输入数据。</p>
<p>CoLAKE[89] 具体如图8所示，结合知识子图和全连的单词图，获得单词-知识图，然后作为模型新的输入，模型还需要分辨新输入中节点的种类并初始化不同的节点。（？）</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104184307.png" srcset="/img/loading.gif" lazyload alt="图8"></p>
<p>DKPLM[101]提出了长尾实体的概念，表示那些语料中尚未完全被学好的实体。在预训练阶段增强这些长尾实体的学习能够增强模型理解上下文的能力。因此，一个叫做KLT的测量方法被提出，用来测定长尾实体，更低的KLT分数表示更可能是长尾实体。KLT分数通过下式得到：<br>$$<br>KLT(e)=\mathbb{I}<em>{Freq(e)&lt;R</em>{freq}} \cdot SI(e) \cdot KC(e)<br>$$<br>式子是三项相乘，第一项是该词的出现概率，第二项是semantic importance，第三项是知识图谱中的邻居节点。如图9所示，DKPLM替换长尾想来那个的embedding为<code>[LTE]</code>，这个embedding叫做pseudo token，其通过知识图谱中的三元组编码得到。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104192532.png" srcset="/img/loading.gif" lazyload alt="图9"></p>
<h4 id="添加知识融合模块"><a href="#添加知识融合模块" class="headerlink" title="添加知识融合模块"></a>添加知识融合模块</h4><p>与上一小节不同，这一节的方法都设计了模态空间的融合，文本和知识模态先各自编码，然后通过一个额外的模块来进行融合。如图10所示，知识融合模块通常出现在三个位置：（a）整个PLM的上方 （b）PLM的Transformer层之间 （c）PLM的Transformer层内</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104193034.png" srcset="/img/loading.gif" lazyload alt="图10"></p>
<p>（a）这种方法可以细分成两类，一类是ERNIE为代表的T-K结构，主要以实体嵌入的形式集成知识，T-Encoder用来编码文本语料，K-Encoder用来将实体嵌入编码进文本空间。许多KEPLM使用这种结构，但是区别在于如何获得实体嵌入。ERNIE通过TransE获得单个三元组的嵌入来训练，这种方式不包含相邻节点。BERT-MK[32]则基于此考虑了邻居节点的信息来学习实体嵌入。由于ERNIE方法的嵌入无法根据上下文动态变化，CokeBERT给邻居节点加权，意思更接近的邻居节点获得更多的权重。（a）方法的第二类则是将知识融合的结构附加在PLM后，比如注意力机制。文献[104]就探索使用注意力机制来集成与句子相关的三元组，JointLK[14] 则令问题token和知识图谱节点互相施加注意力。KET[46] 采用了一种分层自注意力机制来集成情感知识到文本中。文献[93]则编码了相关三元组，并通过门控机制进行模态融合。还有其他的方法基于节点的交互进行融合，两个模块的信息通过节点的交互进行融合。QA-GNN[12]通过节点的交互，集成了文本空间的信息到知识空间，在常识QA中取得了好结果。受此启发，<strong>GreaseLM</strong>[13]设计了两个模态节点的交互，两个模块能分别进行学习，并在融合层进行信息交互，如图11所示。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230104194549.png" srcset="/img/loading.gif" lazyload alt="图11"></p>
<p>（b）这类方法则是在Transformer层之间添加知识融合模块，KnowBERT在Transformer的Encoder block之间添加了新的模块来融入知识，它考虑到了ERNIE的一个关于一词多义的问题：对于一个多义词，融入的知识应该根据其在上下文中的具体含义来。KG-BERT在Encoder和Decoder的层之间添加了知识融合层来融入知识子图的知识，这个过程使用了多头图注意力机制。JAKET[105]将PLM分成前6层和后6层，前6层先得到文本的hidden表示，然后实体也同样用6层得到embedding，之后在文本中将实体的embedding加上，再作为输入进行后6层的学习。</p>
<p>（c）这类方法则是在Transformer层中间添加融合模块。KALA就是一个例子，受到了modulation的启发，即使用知识空间的知识来调制文本空间的embedding。</p>
<p>添加知识融合模块是很符合直觉的，并且融入的知识主要是实体的特征，一些方法还考虑实体在知识图谱中的上下文，比如BERT-MK，还有一些方法基于文本的上线爱问来过滤实体的邻居节点，比如CokeBERT。</p>
<h4 id="使用外部记忆模块"><a href="#使用外部记忆模块" class="headerlink" title="使用外部记忆模块"></a>使用外部记忆模块</h4><p>使用外部记忆模块是搭建KEPLM的第三种方法，其使用了外部记忆来将知识空间与文本空间分离。</p>
<p>如图12，①表示从外部记忆中将非参数化的知识应用在下游任务的方法。KGLM[106] 从相关的知识图谱中选择一些事实来生成事实语句，也就是说它用知识库来扩充词汇量，补充模型没见过的知识。REALM[107] 则引入了知识检索模块来帮助模型检索和处理知识语料中的文本，从而改进在开放域QA的表现。如果知识变化了，它仅需要更新知识语料库而不用重新训练模型。</p>
<p>②则是使用一个额外的模块来学习参数化知识的方法。K-Adapter[72] 添加了用来学习参数化知识的adapter，PLM本身的参数在预训练中保持不变。这些adapter相互独立并且平行训练，当需要时，也可加入更多的adapter。</p>
<p>RAG[108]结合了上面两种方法，在开放域QA任务中带来了更好的效果，并且对于文本生成，它也能生成更具体、更多样、更具备事实的文本。文献[109] 还在RAG的基础上天极爱了一个记忆力模块来提升效果。</p>
<p>当知识库发生变化时，使用外部记忆模块的方法就有更大的优势，更符合实际应用。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107162802.png" srcset="/img/loading.gif" lazyload alt="图12"></p>
<h2 id="评估KEPLM"><a href="#评估KEPLM" class="headerlink" title="评估KEPLM"></a>评估KEPLM</h2><p>这块兴趣不是很大就不翻译了。</p>
<h2 id="应用KEPLM"><a href="#应用KEPLM" class="headerlink" title="应用KEPLM"></a>应用KEPLM</h2><p>KEPLM可以在知识密集的下游任务中大大提升效果，这些任务可以一句是否有新自然语言的生成而分成两类。</p>
<h3 id="知识增强的NLU"><a href="#知识增强的NLU" class="headerlink" title="知识增强的NLU"></a>知识增强的NLU</h3><p>使用Transformer的编码器或者编解码器构成的KEPLM可以用作NLU（natural language understanding）任务，比如实体分类、实体识别、关系提取、情感分析、问答、基于语言的推理和知识图谱补全。</p>
<h4 id="实体分类"><a href="#实体分类" class="headerlink" title="实体分类"></a>实体分类</h4><p>已知实体提示和其上下文，实体分类需要模型能够得出其语义类型。FIGER[122]和Open Entity[123]是最常用的数据集。我们发现CoLAKE、KnowBERT、KEPLER、DKPLM、LUKE至在Open Entity上测试。ERICA只在FIGER上测试。ERNIE、CokeBERT、K-Adapter在两个数据集上测试过。Open Entity更广泛，原因如下：FIGER的训练集通过远程指导标注，测试集则是人工标注，Open Entity则都是人工标注，并且有更多种类更细粒度。除此以外，BERT-MK还在医学领域进行此任务，使用了<code>2010 i2b2/VA</code>、JNLPBA、BC5CDR数据集。</p>
<p>大部分上述提到的方法在需要分类的实体前后添加特殊标记，比如<code>he had a differential diagnosis of [E] asystole [/E]</code>，然后用<code>[E]</code>来预测实体种类。</p>
<p>文献[128]提出了一个新的数据集WikiWiki，包含10M Wikipedia文章，其中每个实体都连接到了Wikidata的知识图谱。与现有数据集对比，WikiWiki更大更准确。</p>
<h4 id="实体识别"><a href="#实体识别" class="headerlink" title="实体识别"></a>实体识别</h4><p>即NER任务（Named Entity Recognition），需要模型识别出文本中实体的种类。和实体分类一样列在表6。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107190839.png" srcset="/img/loading.gif" lazyload alt="表6"></p>
<h4 id="关系提取"><a href="#关系提取" class="headerlink" title="关系提取"></a>关系提取</h4><p>KEPLM可以帮助提升文本间实体关系提取。除了公共领域，这个任务更常见于生物医学领域。如表7所示，最常用的通用数据集是TACRED[143]和FewRel[145]，尤其是前者更常用。我们发现用了这两个数据集的方法在FewRel上表现都比TACRED好，所以TACRED是一个更难的数据集。有许多工作专门为生物医学领域设计，与NER一样，这个任务可以帮助模型了解某个特别领域的知识。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107192110.png" srcset="/img/loading.gif" lazyload alt="表7"></p>
<h4 id="情感分析"><a href="#情感分析" class="headerlink" title="情感分析"></a>情感分析</h4><p>有两种情感分析任务，第一是句子级别的，第二是aspect级别的。句子级别的情感分析需要模型分辨一句话的情感倾向，通常用的数据集有Stanford Sentiment Treebank SST-2[151] 和Amazon-2[152]。aspect级别的情感分析需要模型分析上下文的不同方面（注：aspect是评论的对象实体属性，如在餐厅评论中，一个方面可以是食品的价格，质量等），通常用的数据集有SemEval-2014 Task 4[153]。</p>
<p>SentiLARE、SKEP通过融入知识比普通的PLM在两个方向上的表现都更好。通过情感分析，REMOTE[48]可以检测仇恨语言，KET[46]可以检测对话的情感，帮助QA机器人更好的回应。</p>
<h4 id="问答"><a href="#问答" class="headerlink" title="问答"></a>问答</h4><p>问答包括阅读理解（MRQA）、开放域QA、多选QA。表8中MRQA提供了问题和关联的文章，模型需要从文章中得到答案，最常用数据集是SQuAD1.1 [113]。开放域QA则没有关联的文章，需要模型自行检索相关文章。REALM、K-Adapter、WKLM、EAE在融入百科知识后比一半的模型表现更好。多选QA需要模型在多个选项中根据问题选出正确的选项。表8列出了三个数据集。开放域QA和MRQA的数据集有重合，因为去掉文章就可以变成开放域的。</p>
<p><img src="https://kamino-img.oss-cn-beijing.aliyuncs.com/20230107192128.png" srcset="/img/loading.gif" lazyload alt="表8"></p>
<h4 id="基于语言的推理"><a href="#基于语言的推理" class="headerlink" title="基于语言的推理"></a>基于语言的推理</h4><p>典型的模型有SMedBERT、文献[162]（自然语言推理）、KMLM、文献[163]（数学推理）、文献[24]（常识推理）、Vokenization（常识推理）、CoCoLM（时间时序推理）、VALM（物体颜色大小推理）</p>
<h4 id="知识图谱补全"><a href="#知识图谱补全" class="headerlink" title="知识图谱补全"></a>知识图谱补全</h4><p>知识图谱经常遇到不完整的问题，实体间的许多关系可能缺失。KEPLM可以帮助推理这些链接。GLM这类模型比基于翻译的图嵌入模型和图卷积网络表现更好。</p>
<h3 id="知识增强的NLG"><a href="#知识增强的NLG" class="headerlink" title="知识增强的NLG"></a>知识增强的NLG</h3><p>NLG指自然语言生成，基于Transformer解码器或者编解码器的KEPLM可以用来进行NLG，比如句子生成、对话生成、问题生成和回答生成。</p>
<h4 id="句子生成"><a href="#句子生成" class="headerlink" title="句子生成"></a>句子生成</h4><p>句子生成任务要求模型生成合理的句子，常用数据集有CommonGen、ROCStories。前者需要模型根据3-5个概念生成合适的关联句子，KG-BART模型通过结合常识知识子图进行此任务，GRF、[171]、[23]则能够借助常识生成合理的故事结局。</p>
<h4 id="对话生成"><a href="#对话生成" class="headerlink" title="对话生成"></a>对话生成</h4><p>对话生成需要模型根据上下文生成回应。KnowledGPT在Wizard和CMU_DoG数据集上实验。Wizard数据集有广泛的主题，CMU_DoG只专注于电影领域。</p>
<h4 id="问题生成"><a href="#问题生成" class="headerlink" title="问题生成"></a>问题生成</h4><p>这个任务需要模型根据回答生成问题，RAG提出了Jeopardy Question Genration任务，Jeopardy指模型要根据提供的事实来猜测出一个实体。</p>
<h4 id="回答生成"><a href="#回答生成" class="headerlink" title="回答生成"></a>回答生成</h4><p>与QA不同，回答生成需要模型自己生成，而不是从选项或者文章中找到答案。RAG只使用MSMARCO NLGT taskv2.1，把这个任务当做开放域抽象QA任务并超越了BART。</p>
<h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><ol>
<li><p>利用更多种类的知识</p>
<p>如第三章所示，现有的KEPLM考虑使用多方面的知识，但是还有很多其他的知识值得利用，比如HyTE这样的时序知识图谱，其包含能够反映各个实体间关系随着时间的变化的事件，若利用上这个只是，PLM可以帮助与时间有关的推理任务。并且随着ChatGPE的现象级成功，它证明了使用Reinforcement Learning from Human Feedback来融入人类意图和偏好的威力。</p>
</li>
<li><p>提升知识融合的有效性（Effectiveness）</p>
<p>如第四章所述，许多融入知识的方法已经提取，像KEPLER和Coke-BERT这些方法依赖于精密的多任务预训练和知识图谱嵌入。然而KEPLER在实体分类和关系预测任务中比只有实体级别知识的LUKE更差，CokeBERT也只好一点点。这些说明他们的效率比不上LUKE。文献[178]提出了图卷积Simulator来检测融入PLMd知识。他们对于ERNIE和K-Adapter的调查显示这些KEPLM只融入了知识的一小部分。</p>
</li>
<li><p>提升知识融合的效率（Efficiency）</p>
<p>现有的KEPLM都在刷榜，很少注意知识融入的成本。我们需要更节约时间和空间的解决方案。比如CoLAKE和ERNIE这些方法，在预训练阶段进行知识融合，比如K-BERT和K-Adapter和Syntax-BERT这些方法在微调阶段进行知识融合。在预训练阶段的融合成本更高但效果更好，需要减少预训练的知识融入消耗并维持好效果。</p>
<p>并且，知识融合可能提升推理时间，比如GRF和KG-BART包含了知识图谱子图的构建，造成了更长的推理时间。要应用的话，KEPLM要减少推理时间。</p>
<p>额外的空间占用也是部署上的一个问题，FaE[179]模型需要外部的包含了百万级别的知识三元组实体记忆和事实记忆。RAG依赖于千万级别的知识语料库。然而并不是所有都有用，所以挑选并存储哪些最重要的外部知识可以显著减少空间的过度消耗。</p>
<p>为了减少融入更不重要的知识，模型压缩技巧[180]可以起到帮助，比如quantization[181]、知识蒸馏[182]和参数共享[183]可以用上。</p>
</li>
<li><p>探索更多知识密集型任务</p>
<p>比起第六章所说的NLP下游任务，一些其他更少被探索的应用可能也能对KEPLM起到帮助，比如KEPLM可以用来提升机器翻译和文本总结的评估。</p>
</li>
<li><p>建立一个统一的KEPLM</p>
<p>大多数KEPLM被设计为专门的几个任务。为了在不同的任务上取得SOTA，经常是需要为每一个任务训练不同的模型，要是有一个统一的预训练KEPLM就更好。KGI是一个早期的尝试。</p>
</li>
<li><p>进行Zero/Few-shot学习</p>
<p>一些任务没有高质量的标注数据，所以Zero/Few-shot学习很重要，借助KEPLM中的知识，其比普通PLM更有可能克服这个问题。KALM[99]标记了输入的实体，极大提升了zero-shot QA任务，[128]引入了细粒度的实体种类，也在zero-shot对话追踪中获得了好效果。除了整合知识，prompt也有用[185-188]，结合其与KEPLM也是一个有趣的方向。</p>
</li>
<li><p>提升鲁棒性和可解释性</p>
<p>可解释性指的是人能够理解模型的输出和预测。[189]调查了融入外部知识能否帮助解释自然语言推理任务。他们论证了自动评估方法和人工评分间仍存间隙，自动评估的有效性需要注意。[190]尝试依靠模型输出来追踪到其训练数据。[191]和[192]另一方面尝试定位模型中的只是。模型的鲁棒性指的是遇到有毒的知识和对抗攻击时模型的抵抗能力。[162]通过注意力机制提升了鲁棒性，[144]通过研究模型在不同数据集上的自适应能力来说明鲁棒性。现有方法在这方面还有欠缺。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>略</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/">论文笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/PLM/">PLM</a>
                    
                      <a class="hover-with-bg" href="/tags/Knowledge-Enhanced/">Knowledge-Enhanced</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/01/08/%E5%9B%BE%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9A%E4%BB%8EGCN%E5%88%B0GAT%E5%86%8D%E5%88%B0Relation-aware/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">图神经网络学习笔记：从GCN到GAT再到Relation-aware GNN</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/05/DEKCOR%20%E5%A4%96%E9%83%A8%E7%9F%A5%E8%AF%86%E7%94%A8%E6%9D%A5commonsense%20QA/">
                        <span class="hidden-mobile">DEKCOR：使用外部知识来进行常识QA任务</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'Kamino666/kamino666.github.io');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-svg.js" ></script>

  





  <script  src="https://cdn.jsdelivr.net/npm/mermaid@8.8.3/dist/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>




  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?4a5b4b79f797585f54a6f176ffa56438";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
